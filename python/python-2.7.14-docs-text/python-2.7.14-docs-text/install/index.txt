installation des modules python (Version historique)
****************************************************

Author:
   Greg Ward

Voir aussi:

  L’installation de modules Python
     The up to date module installation documentations

Ce document décrit les utilitaires de distribution de Python («
Distutils ») du point de vue de l’utilisateur final, décrivant comment
étendre les capacités d’une installation standard de python en
construisant et installant des modules python tiers et des extensions.

Note: This guide only covers the basic tools for building and
  distributing extensions that are provided as part of this version of
  Python. Third party tools offer easier to use and more secure
  alternatives. Refer to the quick recommendations section in the
  Python Packaging User Guide for more information.


Introduction
============

Bien que la vaste bibliothèque standard de Python comble beaucoup de
besoins en programmation, il arrive souvent un moment où vous avez
besoin d’ajouter de nouvelles fonctionnalités à votre installation de
Python, via des modules tiers. Cela peut être nécessaire pour vous
aider à écrire vos programmes ou pour prendre en charge une
application écrite en Python que vous souhaitez utiliser.

Dans le passé, il y a eu peu de prise d’aide à l’ajout de modules
tiers sur une installation existante de Python. Avec l’introduction
des utilitaires de distribution de Python (Distutils pour faire plus
court) dans Python 2.0, ceci a changé.

Ce document s’adresse principalement aux personnes qui ont besoin
d’installer des modules tiers de Python : les utilisateurs finaux et
les administrateurs système, qui ont juste besoin de faire fonctionner
une application Python, et les programmeurs Python, qui veulent
ajouter de nouvelles fonctionnalités à leur boîte à outils. Vous
n’avez pas besoin de connaître Python pour lire ce document. Il y aura
quelques brèves utilisations du mode interactif de Python pour
explorer votre installation, mais c’est tout. Si vous cherchez des
informations sur la façon de distribuer vos propres modules Python
afin que d’autres puissent les utiliser, allez voir le manuel
Distributing Python Modules (Legacy version).  Debugging the setup
script peut aussi être intéressant.


Le meilleur des cas : l’installation simple
-------------------------------------------

Dans le meilleur des cas, quelqu’un aura préparé une version spéciale
de la distribution du module que vous souhaitez installer qui est
destiné spécifiquement à votre plateforme et elle va s’installer comme
n’importe quel autre logiciel sur votre plateforme. Par exemple, le
développeur du module pourrait faire un installeur exécutable
disponible pour les utilisateurs Windows, un paquetage RPM pour les
utilisateurs de systèmes Linux basés sur RPM (Red Hat, SuSE, Mandrake
et bien d’autres), un paquet Debian pour les utilisateurs de Linux
basé sur le système Debian et ainsi de suite.

Dans ce cas, vous devez télécharger le programme d’installation
approprié à votre plateforme et faire d’elle ce qui vous semble
évident : l’exécuter s’il s’agit d’un exécutable d’installation,  "rpm
--install" si c’est un RPM, etc. Vous n’avez même pas besoin
d’exécuter Python ou un script d’installation, vous n’avez pas besoin
de compiler quoi que ce soit – vous devriez même pas avoir besoin de
lire toutes les instructions (même si c’est toujours une bonne idée de
le faire).

Bien sûr, les choses ne seront pas toujours aussi simple que cela.
Vous pourriez être intéressés par une distribution d’un module qui n’a
pas de programme d’installation facile à utiliser pour votre
plateforme. Dans ce cas, vous allez devoir repartir des fichiers
sources publiés par l’auteur/mainteneur du module. L’installation à
partir des sources n’est pas très difficile, du moment que les modules
en question sont packagés de façon standard. Le cœur de ce document
explique comment configurer et installer des modules à partir des
sources.


Le nouveau standard: Distutils
------------------------------

Si vous téléchargez une distribution source du module, vous pouvez
dire assez rapidement s’il a été packagé et distribué de la façon
standard, c’est à dire en utilisant Distutils. Premièrement, le nom et
le numéro de version de la distribution seront affichés en bonne place
dans le nom de l’archive téléchargée, par exemple "foo-1.0.tar.gz" ou
"widget-0.9.7.zip". Ensuite, l’archive va se décompresser dans un
répertoire du même nom : "foo-1.0" ou "widget-0.9.7". En outre, la
distribution va contenir un script d’installation "setup.py" et un
fichier nommé "README.txt" ou éventuellement juste "README", qui doit
expliquer que la construction et l’installation de la distribution du
module se fait simplement en exécutant ceci :

   python setup.py install

For Windows, this command should be run from a command prompt window
(Start ‣ Accessories):

   setup.py install

Si toutes ces choses sont vérifiées, alors vous savez déjà comment
construire et installer le module que vous venez de télécharger : en
exécutant la commande ci-dessus. Sauf si vous avez besoin d’installer
les choses d’une manière non standard ou de personnaliser le processus
de construction, vous n’avez pas vraiment besoin de ce manuel. Ou
plutôt, la commande ci-dessus est tout ce dont vous avez besoin de
sortir de ce manuel.


Construction standard et installation
=====================================

Comme décrit dans la section Le nouveau standard: Distutils, la
construction et l’installation d’une distribution d’un module en
utilisant Distutils est habituellement fait avec la commande dans un
terminal :

   python setup.py install


Différences selon les plateformes
---------------------------------

Vous devez toujours exécuter la commande « setup » à partir du
répertoire racine de la distribution, à savoir le sous-répertoire de
niveau supérieur à celui où se sont décompressées les sources de la
distribution du module. Par exemple, si vous venez de télécharger les
sources d’une distribution du module "foo-1.0.tar.gz" sous un système
Unix, la méthode normale consiste à faire :

   gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
   cd foo-1.0
   python setup.py install

Sous Windows, vous avez probablement téléchargé "foo-1.0.zip". Si vous
avez téléchargé le fichier d’archive dans "C:\Temp", il se
décompressera alors dans "C:\Temp\foo-1.0" ; vous pouvez utiliser soit
un manipulateur d’archive avec une interface graphique (comme WinZip)
soit un outil de ligne de commande (telles que **unzip** ou
**pkunzip**) pour décompresser l’archive. Ensuite, ouvrez une fenêtre
d’invite de commandes et exécutez :

   cd c:\Temp\foo-1.0
   python setup.py install


Fractionnement du travail
-------------------------

Exécuter "setup.py install" construit et installe tous les modules en
un seul coup. Si vous préférez travailler progressivement – ce qui est
particulièrement utile si vous souhaitez personnaliser le processus de
construction, ou si les choses vont mal – vous pouvez utiliser le
script de configuration pour faire une chose à la fois. Cela est
particulièrement utile lorsque la construction et l’installation doit
être faite par différents utilisateurs – par exemple, vous pouvez
vouloir construire une distribution d’un module et la transférer à un
administrateur système pour l’installation (ou le faire vous-même,
avec les privilèges de super-utilisateur).

Par exemple, vous pouvez construire tout en une seule étape et ensuite
installer le tout dans une deuxième étape, en invoquant le script
d’installation deux fois :

   python setup.py build
   python setup.py install

Si vous faites cela, vous remarquerez que l’exécution de la commande
**install** lance d’abord la commande **build**, qui, dans ce cas,
s’aperçoit vite qu’il n’a rien à faire, puisque tout dans le dossier
"build" est à jour.

Il se peut que vous n’ayez pas souvent besoin de cette capacité à
découper les étapes si tout ce que vous faite est d’installer les
modules téléchargés sur le Net, mais c’est très pratique pour des
tâches plus avancées. Si vous en venez à distribuer vos propres
modules et extensions Python, vous allez exécuter beaucoup de
commandes individuelles de Distutils, indépendamment les unes des
autres.


Comment fonctionne une construction
-----------------------------------

Comme sous-entendu ci-dessus, la commande **build** est chargée de
mettre les fichiers à installer dans un *répertoire de travail*. Par
défaut, c’est "build" à la racine de la distribution ; si vous êtes
très préoccupés par la vitesse, ou si vous voulez conserver
l’arborescence des sources d’origine, vous pouvez changer le
répertoire de construction avec l’option "--build-base". Par exemple :

   python setup.py build --build-base=/path/to/pybuild/foo-1.0

(Ou vous pourriez le faire de façon permanente avec une directive dans
votre système ou dans le fichier de configuration personnelle de
Distutils ; voir la section Distutils Configuration Files.)
Normalement, ce n’est pas nécessaire.

La mise en page par défaut pour l’arbre de compilation se présente
comme suit :

   --- build/ --- lib/
   or
   --- build/ --- lib.<plat>/
                  temp.<plat>/

où "<plat>" représente une brève description de l’actuel système
d’exploitation / plateforme matérielle et la version Python. La
première forme, avec juste un dossier "lib" est utilisé pour les
«distributions de modules purs » – c’est-à-dire des distributions de
module qui ne incorporent que des modules en Python. Si un module de
la distribution contient au moins une extension (modules écrits en
C/C++), alors il faut utiliser la deuxième forme, avec deux dossiers
"<plat>". Dans ce cas, le répertoire "temp.*plat*" contient les
fichiers temporaires générés par le processus de compilation et de
lien qui ne seront pas installés. Dans les deux cas, le dossier "lib"
(ou "lib.*plat*") contient tous les modules Python (Python pur et
extensions) qui seront installés.

Dans l’avenir, d’autres répertoires seront ajoutés pour gérer les
scripts Python, de la documentation, des exécutables binaires et tout
ce qui est nécessaire pour gérer le travail de l’installation de
modules et d’applications Python.


Comment fonctionne l’installation
---------------------------------

Après l’exécution de la commande **build** (que vous l’ayez exécutez
explicitement ou que la commande **install** l’ai fait pour vous), le
travail de la commande **install** est relativement simple : tout ce
qu’il a à faire est de copier tout ce qui est sous "build/lib" (ou
"build/lib.*plat*") dans le répertoire que vous avez choisi pour
l’installation.

Si vous ne choisissez aucun répertoire d’installation – c’est-à-dire,
si vous lancez simplement "setup.py install"– alors la commande
**install** installe à l’emplacement standard pour les modules tiers
de Python. Cet emplacement varie selon la plateforme et selon la façon
dont vous avez construit et/ou installés Python lui-même. Sous Unix
(et Mac OS X, qui est également basé sur Unix), il dépend aussi de
savoir si le module de la distribution en cours d’installation est en
pur Python ou contient des extensions (« non-pur »):

+-------------------+-------------------------------------------------------+----------------------------------------------------+---------+
| Plateforme        | Emplacement standard de l’installation                | Valeur par défaut                                  | Notes   |
+===================+=======================================================+====================================================+=========+
| Unix (pur)        | "*prefix*/lib/python*X.Y*/site-packages"              | "/usr/local/lib/python*X.Y*/site-packages"         | (1)     |
+-------------------+-------------------------------------------------------+----------------------------------------------------+---------+
| Unix (non-pur)    | "*exec-prefix*/lib/python*X.Y*/site-packages"         | "/usr/local/lib/python*X.Y*/site-packages"         | (1)     |
+-------------------+-------------------------------------------------------+----------------------------------------------------+---------+
| Windows           | "*prefix*\Lib\site-packages"                          | "C:\Python*XY*\Lib\site-packages"                  | (2)     |
+-------------------+-------------------------------------------------------+----------------------------------------------------+---------+

Notes :

1. La plupart des distributions Linux incluent Python comme un
   élément de base du système, donc : file: *{prefix}* et : ​​file:
   *{exec- prefix}* sont généralement tous les deux : file: */ usr*
   sous Linux. Si vous construisez vous-même Python sous Linux (ou
   tout autre système de type Unix), les valeurs par défaut de : file:
   *{prefix}* et: ​​file: *{exec-prefix}* sont souvent : file: */ usr
   /* locales.

2. Sous Windows, le dossier d’installation par défaut était :
   "C:\Program Files\Python" sous Python 1.6a1, 1.5.2 et avant.

"*prefix*" et "*exec-prefix*" désignent les répertoires dans lesquels
Python est installé et où il trouve les librairies lors de
l’exécution. Ils sont toujours identiques sous Windows et très souvent
les mêmes sous Unix et Mac OS X. Vous pouvez trouver ce que votre
installation de Python utilise pour "*prefix*" et "*exec-prefix*" en
exécutant Python en mode interactif et en tapant quelques commandes
simples. Sous Unix,  taper seulement "python" à l’invite du shell.
Sous Windows, sélectionner Démarrer ‣ Programmes ‣ Python X.Y ‣ Python
(ligne de commande). Un fois l’interpréteur démarré, vous taper du
code Python à l’invite de commande. Par exemple, sur mon système
Linux, je tape les trois instructions ci-dessous et obtient la sortie
comme indiqué pour trouver mes  "*prefix*" et "*exec-prefix*":

   Python 2.4 (#26, Aug  7 2004, 17:19:02)
   Type "help", "copyright", "credits" or "license" for more information.
   >>> import sys
   >>> sys.prefix
   '/usr'
   >>> sys.exec_prefix
   '/usr'

A few other placeholders are used in this document: "*X.Y*" stands for
the version of Python, for example "2.7"; "*distname*" will be
replaced by the name of the module distribution being installed.  Dots
and capitalization are important in the paths; for example, a value
that uses "python2.7" on UNIX will typically use "Python27" on
Windows.

Si vous ne voulez pas installer des modules à l’emplacement standard,
ou si vous n’avez pas la permission d’écrire là-bas, alors vous avez
besoin de lire la section Installation Alternative sur les
alternatives d’installation. Si vous souhaitez personnaliser vos
répertoires d’installation plus fortement, allez voir la section
Custom Installation sur les installations personnalisées.


Installation Alternative
========================

Il est souvent nécessaire ou désirable d’installer des modules à un
emplacement autre que l’emplacement standard pour les modules Python
tiers. Par exemple, sur un système Unix il est possible que vous
n’ayiez pas la permission d’écrire dans le dossier standard pour les
modules tiers. Ou vous pouvez vouloir essayer un module avant d’en
faire une partie standard de vtre installation locale de Python. C’est
surtout vrai lors d’une mise à jour d’une distribution déjà présente :
vous voulez vous assurer que votre base de scripts marche encore avec
la nouvelle version avant de faire la mise à jour pour de vrai.

La commande **install** de Distutils est conçue pour rendre
l’installation de distributions de modules à un emplacement alternatif
simple et sans douleur. L’idée de base est que vous lui fournissez un
dossier de base pour l’installation, et la commande **install**
choisit un ensemble de dossier (appelé le *schéma d’installation*)
dans lequel elle installe les fichiers. Les détails diffèrent d’une
plateforme à une autre, donc lisez la section ci-dessous qui
s’applique à vous.

Notez que les différents schémas d’installation alternative sont
mutuelement exclusif : vous pouvez passer "--user", ou "--home", ou "
--prefix" et "--exc-prefix", ou "--install-base" and "--install-
platbase", mais vous ne pouvez pas mélanger ces groupes.


Installation alternative : le schéma *user*
-------------------------------------------

Ce schéma est conçu pour être la solution la plus pratique pour les
utilisateurs qui n’ont pas la permission d’écrire dans le dossier
site-packages global, ou qui ne veulent pas y écrire. Il est activé
avec une simple option :

   python setup.py install --user

Les fichiers seront installés dans des sous-dossiers de
"site.USER_BASE" (écrit "*userbase*" dans la suite). Ce schéma
installe des modules Python purs et les modules d’extension au même
endroit (aussi connu sous le nom de "site.USER_SITE").Voici les
valeurs pour UNIX, y compris Mac OS XX :

+-----------------+-------------------------------------------------------------+
| Type de fichier | Dossier d’installation                                      |
+=================+=============================================================+
| modules         | "*userbase*/lib/python*X.Y*/site-packages"                  |
+-----------------+-------------------------------------------------------------+
| scripts         | "*userbase*/bin"                                            |
+-----------------+-------------------------------------------------------------+
| données         | "*userbase*"                                                |
+-----------------+-------------------------------------------------------------+
| en-têtes C      | "*userbase*/include/python*X.Y*/*distname*"                 |
+-----------------+-------------------------------------------------------------+

Et voici les valeurs utilisées sur Windows :

+-----------------+-------------------------------------------------------------+
| Type de fichier | Dossier d’installation                                      |
+=================+=============================================================+
| modules         | "*userbase*\Python*XY*\site-packages"                       |
+-----------------+-------------------------------------------------------------+
| scripts         | "*userbase*\Scripts"                                        |
+-----------------+-------------------------------------------------------------+
| données         | "*userbase*"                                                |
+-----------------+-------------------------------------------------------------+
| en-têtes C      | "*userbase*\Python*XY*\Include\*distname*"                  |
+-----------------+-------------------------------------------------------------+

L’avantage d’utiliser ce schéma plutôt que les autres décrits plus bas
est que le dosser site-package du schéma *user* est en temps normal
toujours inclu dans "sys.path" (voir "site" pour plus d’informations),
ce qui signifie qu’il n’y a rien d’autre à faire après avoir exécuté
le script "setup.py" pour finaliser l’installation.

The **build_ext** command also has a "--user" option to add
"*userbase*/include" to the compiler search path for header files and
"*userbase*/lib" to the compiler search path for libraries as well as
to the runtime search path for shared C libraries (rpath).


Installation alternative : le schéma home
-----------------------------------------

L’idée derrière le « schéma home » est que vous compilez et maintenez
un espace personnel de modules Python. Le nom de ce schéma vient de
l’idée du dossier « home » sur Unix, vu qu’il n’est pas rare pour un
utilisateur Unix de construire leur dossier *home* avec la même
disposition que "/usr/" or "/usr/local/". Ce schéma peut être utilisé
par n’importe qui, quel que soit le système d’exploitation.

Installer une nouvelle distribution de module est aussi simple que :

   python setup.py install --home=<dir>

où vous pouvez fournir le dossier de votre choix à l’option "--home".
Sur Unix, les paresseux pourront juste mettre un tilde ("~") ; la
commande **install** le remplacera par le chemin vers votre dossier
*home* :

   python setup.py install --home=~

Pour que Python puisse trouver les distributions installées avec ce
schéma, vous devez modifier le chemin de recherche de Python ou
modifier "sitecustomize" (voir "site") pour appeller
"site.addsitedir()" ou modifiez "sys.path".

L’option "--home" définit le dossier de base de l’installation. Les
fichiers sont installés dans les dossiers suivants dans la base de
l’installation de la façon suivante :

+-----------------+-------------------------------------------------------------+
| Type de fichier | Dossier d’installation                                      |
+=================+=============================================================+
| modules         | "*home*/lib/python"                                         |
+-----------------+-------------------------------------------------------------+
| scripts         | "*home*/bin"                                                |
+-----------------+-------------------------------------------------------------+
| données         | "*home*"                                                    |
+-----------------+-------------------------------------------------------------+
| en-têtes C      | "*home*/include/python/*distname*"                          |
+-----------------+-------------------------------------------------------------+

(Remplacez mentalement les slashs avec des backslashs si vous êtes sur
Windows.)

Modifié dans la version 2.4: The "--home" option used to be supported
only on Unix.


Installation alternative : Unix (le schéma de préfixe)
------------------------------------------------------

Le « schéma prefix » est utile quand vous voulez une installation de
Python pour faire la compilation/l’installation (ie. exécuter le
script *setup*), mais utiliser les modules tiers d’une installation
Python différente (ou quelque chose qui ressemble à une installation
Python différente). Si cela semble inhabituel, ça l’est – c’est
pourquoi les schémas *user* et *home* viennent avant. Cependant, il y
a au moins deux cas connus où le schéma *prefix* est utile.

Premièrement, considérez que beaucoup de distributions Linux mettent
Python dans "/usr", plutôt que le traditionnel "/usr/local". C’est
tout à fait approprié, puisque dans ces cas Python fait partie du «
système » plutôt que d’une addition locale. Cependant, si vous
installez des modules Python depuis leur source, vous voulez
probablement qu’ils aillent dans "/usr/local/lib/python2.*X*" plutôt
que dans "/usr/lib/python2.*X*". Ça peut être fait avec :

   /usr/bin/python setup.py install --prefix=/usr/local

Une autre possibilité est un système de fichier réseau où le nom est
utilisé pour écrire dans un dossier distant qui est différent du nom
utilisé pour le lire : par exemple, l’interprète Python appelé est
"/usr/local/bin/python" et cherche les modules dans
"/usr/local/lib/python2.*X*", mais ces modules doivent être installé
dans, par exemple, "/mnt/*@server*/export/lib/python2.*X*".Ça peut
être fait avec :

   /usr/local/bin/python setup.py install --prefix=/mnt/@server/export

Dans les deux cas, l’option "--prefix" définit la base de
l’installation, et l’option "--exec-prefix" définit la base
d’installation spécifique à la plateforme, qui est utilisé pour des
fichiers spécifiques à la plateforme. (Actuellement, ça ne signifie
que les distributions de modules non-purs, mais peuvent être étendus
aux bibliothèques C, exécutables, etc.). Si "--exec-prefix" n’est pas
fourni, il vaut par défaut "--prefix". Les fichiers sont ainsi :

+-------------------+------------------------------------------------------------+
| Type de fichier   | Dossier d’installation                                     |
+===================+============================================================+
| Modules Python    | "*prefix*/lib/python*X.Y*/site-packages"                   |
+-------------------+------------------------------------------------------------+
| modules           | "*exec-prefix*/lib/python*X.Y*/site-packages"              |
| d’extension       |                                                            |
+-------------------+------------------------------------------------------------+
| scripts           | "*prefix*/bin"                                             |
+-------------------+------------------------------------------------------------+
| données           | "*prefix*"                                                 |
+-------------------+------------------------------------------------------------+
| en-têtes C        | "*prefix*/include/python*X.Y*/*distname*"                  |
+-------------------+------------------------------------------------------------+

Il n’est pas obligatoire que "--prefix" ou "--exec-prefix" pointent
vers une installation alternative de Python. Si les dossiers listés
ci-dessus n’existent pas, ils sont créés au moment de l’installation.

Accessoirement, la vraie raison pour laquelle le schéma *prefix* est
important est simplement qu’une installation Unix standard utilise le
schéma *prefix*, mais avec les options "--prefix" et "--exec-prefix"
fournies par Python lui-même en tant que "sys.prefix" and
"sys.exec_prefix". Vous pouvez donc penser que vous n’utiliserez
jamais le schéma *prefix*, mais à chaque fois que vous lancez "python
setup.py install" sans autre option, vous l’utilisez.

Notez qu’installer des extensions à une installation Python
alternative n’a aucun effet sur la façon dont ces extensions sont
construites. En particulier, les fichers en-tête de Python ("Python.h"
et ses amis) installés avec l’interprète Python utilisé pour exécuter
le script *setup* sera utilisé pour compiler les extensions. Il est de
votre responsabilité de vous assurer que l’interprète utilisé pour
pour exécuter les extensions installées de cette façon est compatible
avec celui utilisé pour les compiler. La meilleure façon pour cela est
de s’assurer qu’ils sont exactement la même version de Python
(possiblement des compilations différentes, ou différentes copies de
la même). (Évidemment, si vos "--prefix" et "--exec-prefix" ne
pointent pas vers une installation alternative de Python, cela n’a pas
de sens.


Alternate installation: Windows (the prefix scheme)
---------------------------------------------------

Windows has no concept of a user’s home directory, and since the
standard Python installation under Windows is simpler than under Unix,
the "--prefix" option has traditionally been used to install
additional packages in separate locations on Windows.

   python setup.py install --prefix="\Temp\Python"

to install modules to the "\Temp\Python" directory on the current
drive.

The installation base is defined by the "--prefix" option; the "--
exec-prefix" option is not supported under Windows, which means that
pure Python modules and extension modules are installed into the same
location. Files are installed as follows:

+-----------------+------------------------------------------------------------+
| Type de fichier | Dossier d’installation                                     |
+=================+============================================================+
| modules         | "*prefix*\Lib\site-packages"                               |
+-----------------+------------------------------------------------------------+
| scripts         | "*prefix*\Scripts"                                         |
+-----------------+------------------------------------------------------------+
| données         | "*prefix*"                                                 |
+-----------------+------------------------------------------------------------+
| en-têtes C      | "*prefix*\Include\*distname*"                              |
+-----------------+------------------------------------------------------------+


Custom Installation
===================

Sometimes, the alternate installation schemes described in section
Installation Alternative just don’t do what you want.  You might want
to tweak just one or two directories while keeping everything under
the same base directory, or you might want to completely redefine the
installation scheme.  In either case, you’re creating a *custom
installation scheme*.

To create a custom installation scheme, you start with one of the
alternate schemes and override some of the installation directories
used for the various types of files, using these options:

+------------------------+-------------------------+
| Type de fichier        | Override option         |
+========================+=========================+
| Modules Python         | "--install-purelib"     |
+------------------------+-------------------------+
| modules d’extension    | "--install-platlib"     |
+------------------------+-------------------------+
| all modules            | "--install-lib"         |
+------------------------+-------------------------+
| scripts                | "--install-scripts"     |
+------------------------+-------------------------+
| données                | "--install-data"        |
+------------------------+-------------------------+
| en-têtes C             | "--install-headers"     |
+------------------------+-------------------------+

These override options can be relative, absolute, or explicitly
defined in terms of one of the installation base directories. (There
are two installation base directories, and they are normally the same—
they only differ when you use the Unix « prefix scheme » and supply
different "--prefix" and "--exec-prefix" options; using "--install-
lib" will override values computed or given for "--install-purelib"
and "--install-platlib", and is recommended for schemes that don’t
make a difference between Python and extension modules.)

For example, say you’re installing a module distribution to your home
directory under Unix—but you want scripts to go in "~/scripts" rather
than "~/bin". As you might expect, you can override this directory
with the "--install-scripts" option; in this case, it makes most sense
to supply a relative path, which will be interpreted relative to the
installation base directory (your home directory, in this case):

   python setup.py install --home=~ --install-scripts=scripts

Another Unix example: suppose your Python installation was built and
installed with a prefix of "/usr/local/python", so under a standard
installation scripts will wind up in "/usr/local/python/bin".  If you
want them in "/usr/local/bin" instead, you would supply this absolute
directory for the "--install-scripts" option:

   python setup.py install --install-scripts=/usr/local/bin

(This performs an installation using the « prefix scheme, » where the
prefix is whatever your Python interpreter was installed with—
"/usr/local/python" in this case.)

If you maintain Python on Windows, you might want third-party modules
to live in a subdirectory of "*prefix*", rather than right in
"*prefix*" itself.  This is almost as easy as customizing the script
installation directory —you just have to remember that there are two
types of modules to worry about, Python and extension modules, which
can conveniently be both controlled by one option:

   python setup.py install --install-lib=Site

The specified installation directory is relative to "*prefix*".  Of
course, you also have to ensure that this directory is in Python’s
module search path, such as by putting a ".pth" file in a site
directory (see "site").  See section Modifying Python’s Search Path to
find out how to modify Python’s search path.

If you want to define an entire installation scheme, you just have to
supply all of the installation directory options.  The recommended way
to do this is to supply relative paths; for example, if you want to
maintain all Python module-related files under "python" in your home
directory, and you want a separate directory for each platform that
you use your home directory from, you might define the following
installation scheme:

   python setup.py install --home=~ \
                           --install-purelib=python/lib \
                           --install-platlib=python/lib.$PLAT \
                           --install-scripts=python/scripts
                           --install-data=python/data

ou :

   python setup.py install --home=~/python \
                           --install-purelib=lib \
                           --install-platlib='lib.$PLAT' \
                           --install-scripts=scripts
                           --install-data=data

"$PLAT" is not (necessarily) an environment variable—it will be
expanded by the Distutils as it parses your command line options, just
as it does when parsing your configuration file(s).

Obviously, specifying the entire installation scheme every time you
install a new module distribution would be very tedious.  Thus, you
can put these options into your Distutils config file (see section
Distutils Configuration Files):

   [install]
   install-base=$HOME
   install-purelib=python/lib
   install-platlib=python/lib.$PLAT
   install-scripts=python/scripts
   install-data=python/data

ou :

   [install]
   install-base=$HOME/python
   install-purelib=lib
   install-platlib=lib.$PLAT
   install-scripts=scripts
   install-data=data

Note that these two are *not* equivalent if you supply a different
installation base directory when you run the setup script.  For
example,

   python setup.py install --install-base=/tmp

would install pure modules to "/tmp/python/lib" in the first case, and
to "/tmp/lib" in the second case.  (For the second case, you probably
want to supply an installation base of "/tmp/python".)

You probably noticed the use of "$HOME" and "$PLAT" in the sample
configuration file input.  These are Distutils configuration
variables, which bear a strong resemblance to environment variables.
In fact, you can use environment variables in config files on
platforms that have such a notion but the Distutils additionally
define a few extra variables that may not be in your environment, such
as "$PLAT".  (And of course, on systems that don’t have environment
variables, such as Mac OS 9, the configuration variables supplied by
the Distutils are the only ones you can use.) See section Distutils
Configuration Files for details.


Modifying Python’s Search Path
------------------------------

When the Python interpreter executes an "import" statement, it
searches for both Python code and extension modules along a search
path.  A default value for the path is configured into the Python
binary when the interpreter is built. You can determine the path by
importing the "sys" module and printing the value of "sys.path".

   $ python
   Python 2.2 (#11, Oct  3 2002, 13:31:27)
   [GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
   Type "help", "copyright", "credits" or "license" for more information.
   >>> import sys
   >>> sys.path
   ['', '/usr/local/lib/python2.3', '/usr/local/lib/python2.3/plat-linux2',
    '/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload',
    '/usr/local/lib/python2.3/site-packages']
   >>>

The null string in "sys.path" represents the current working
directory.

The expected convention for locally installed packages is to put them
in the "*…*/site-packages/" directory, but you may want to install
Python modules into some arbitrary directory.  For example, your site
may have a convention of keeping all software related to the web
server under "/www". Add-on Python modules might then belong in
"/www/python", and in order to import them, this directory must be
added to "sys.path".  There are several different ways to add the
directory.

The most convenient way is to add a path configuration file to a
directory that’s already on Python’s path, usually to the ".../site-
packages/" directory.  Path configuration files have an extension of
".pth", and each line must contain a single path that will be appended
to "sys.path".  (Because the new paths are appended to "sys.path",
modules in the added directories will not override standard modules.
This means you can’t use this mechanism for installing fixed versions
of standard modules.)

Paths can be absolute or relative, in which case they’re relative to
the directory containing the ".pth" file.  See the documentation of
the "site" module for more information.

A slightly less convenient way is to edit the "site.py" file in
Python’s standard library, and modify "sys.path".  "site.py" is
automatically imported when the Python interpreter is executed, unless
the "-S" switch is supplied to suppress this behaviour.  So you could
simply edit "site.py" and add two lines to it:

   import sys
   sys.path.append('/www/python/')

However, if you reinstall the same major version of Python (perhaps
when upgrading from 2.2 to 2.2.2, for example) "site.py" will be
overwritten by the stock version.  You’d have to remember that it was
modified and save a copy before doing the installation.

There are two environment variables that can modify "sys.path".
"PYTHONHOME" sets an alternate value for the prefix of the Python
installation.  For example, if "PYTHONHOME" is set to "/www/python",
the search path will be set to "['', '/www/python/lib/pythonX.Y/',
'/www/python/lib/pythonX.Y/plat-linux2', ...]".

The "PYTHONPATH" variable can be set to a list of paths that will be
added to the beginning of "sys.path".  For example, if "PYTHONPATH" is
set to "/www/python:/opt/py", the search path will begin with
"['/www/python', '/opt/py']".  (Note that directories must exist in
order to be added to "sys.path"; the "site" module removes paths that
don’t exist.)

Finally, "sys.path" is just a regular Python list, so any Python
application can modify it by adding or removing entries.


Distutils Configuration Files
=============================

As mentioned above, you can use Distutils configuration files to
record personal or site preferences for any Distutils options.  That
is, any option to any command can be stored in one of two or three
(depending on your platform) configuration files, which will be
consulted before the command-line is parsed. This means that
configuration files will override default values, and the command-line
will in turn override configuration files.  Furthermore, if multiple
configuration files apply, values from « earlier » files are
overridden by « later » files.


Location and names of config files
----------------------------------

The names and locations of the configuration files vary slightly
across platforms.  On Unix and Mac OS X, the three configuration files
(in the order they are processed) are:

+----------------+------------------------------------------------------------+---------+
| Type de        | Location and filename                                      | Notes   |
| fichier        |                                                            |         |
+================+============================================================+=========+
| system         | "*prefix*/lib/python*ver*/distutils/distutils.cfg"         | (1)     |
+----------------+------------------------------------------------------------+---------+
| personal       | "$HOME/.pydistutils.cfg"                                   | (2)     |
+----------------+------------------------------------------------------------+---------+
| local          | "setup.cfg"                                                | (3)     |
+----------------+------------------------------------------------------------+---------+

And on Windows, the configuration files are:

+----------------+---------------------------------------------------+---------+
| Type de        | Location and filename                             | Notes   |
| fichier        |                                                   |         |
+================+===================================================+=========+
| system         | "*prefix*\Lib\distutils\distutils.cfg"            | (4)     |
+----------------+---------------------------------------------------+---------+
| personal       | "%HOME%\pydistutils.cfg"                          | (5)     |
+----------------+---------------------------------------------------+---------+
| local          | "setup.cfg"                                       | (3)     |
+----------------+---------------------------------------------------+---------+

On all platforms, the « personal » file can be temporarily disabled by
passing the *–no-user-cfg* option.

Notes :

1. Strictly speaking, the system-wide configuration file lives in
   the directory where the Distutils are installed; under Python 1.6
   and later on Unix, this is as shown. For Python 1.5.2, the
   Distutils will normally be installed to
   "*prefix*/lib/python1.5/site- packages/distutils", so the system
   configuration file should be put there under Python 1.5.2.

2. On Unix, if the "HOME" environment variable is not defined, the
   user’s home directory will be determined with the "getpwuid()"
   function from the standard "pwd" module. This is done by the
   "os.path.expanduser()" function used by Distutils.

3. I.e., in the current directory (usually the location of the
   setup script).

4. (See also note (1).)  Under Python 1.6 and later, Python’s
   default « installation prefix » is "C:\Python", so the system
   configuration file is normally
   "C:\Python\Lib\distutils\distutils.cfg". Under Python 1.5.2, the
   default prefix was "C:\Program Files\Python", and the Distutils
   were not part of the standard library—so the system configuration
   file would be "C:\Program Files\Python\distutils\distutils.cfg" in
   a standard Python 1.5.2 installation under Windows.

5. On Windows, if the "HOME" environment variable is not defined,
   "USERPROFILE" then "HOMEDRIVE" and "HOMEPATH" will be tried. This
   is done by the "os.path.expanduser()" function used by Distutils.


Syntax of config files
----------------------

The Distutils configuration files all have the same syntax.  The
config files are grouped into sections.  There is one section for each
Distutils command, plus a "global" section for global options that
affect every command.  Each section consists of one option per line,
specified as "option=value".

For example, the following is a complete config file that just forces
all commands to run quietly by default:

   [global]
   verbose=0

If this is installed as the system config file, it will affect all
processing of any Python module distribution by any user on the
current system.  If it is installed as your personal config file (on
systems that support them), it will affect only module distributions
processed by you.  And if it is used as the "setup.cfg" for a
particular module distribution, it affects only that distribution.

You could override the default « build base » directory and make the
**build*** commands always forcibly rebuild all files with the
following:

   [build]
   build-base=blib
   force=1

which corresponds to the command-line arguments

   python setup.py build --build-base=blib --force

except that including the **build** command on the command-line means
that command will be run.  Including a particular command in config
files has no such implication; it only means that if the command is
run, the options in the config file will apply.  (Or if other commands
that derive values from it are run, they will use the values in the
config file.)

You can find out the complete list of options for any command using
the "--help" option, e.g.:

   python setup.py build --help

and you can find out the complete list of global options by using "--
help" without a command:

   python setup.py --help

See also the « Reference » section of the « Distributing Python
Modules » manual.


Building Extensions: Tips and Tricks
====================================

Whenever possible, the Distutils try to use the configuration
information made available by the Python interpreter used to run the
"setup.py" script. For example, the same compiler and linker flags
used to compile Python will also be used for compiling extensions.
Usually this will work well, but in complicated situations this might
be inappropriate.  This section discusses how to override the usual
Distutils behaviour.


Tweaking compiler/linker flags
------------------------------

Compiling a Python extension written in C or C++ will sometimes
require specifying custom flags for the compiler and linker in order
to use a particular library or produce a special kind of object code.
This is especially true if the extension hasn’t been tested on your
platform, or if you’re trying to cross-compile Python.

In the most general case, the extension author might have foreseen
that compiling the extensions would be complicated, and provided a
"Setup" file for you to edit.  This will likely only be done if the
module distribution contains many separate extension modules, or if
they often require elaborate sets of compiler flags in order to work.

A "Setup" file, if present, is parsed in order to get a list of
extensions to build.  Each line in a "Setup" describes a single
module.  Lines have the following structure:

   module ... [sourcefile ...] [cpparg ...] [library ...]

Let’s examine each of the fields in turn.

* *module* is the name of the extension module to be built, and
  should be a valid Python identifier.  You can’t just change this in
  order to rename a module (edits to the source code would also be
  needed), so this should be left alone.

* *sourcefile* is anything that’s likely to be a source code file,
  at least judging by the filename.  Filenames ending in ".c" are
  assumed to be written in C, filenames ending in ".C", ".cc", and
  ".c++" are assumed to be C++, and filenames ending in ".m" or ".mm"
  are assumed to be in Objective C.

* *cpparg* is an argument for the C preprocessor,  and is anything
  starting with "-I", "-D", "-U" or "-C".

* *library* is anything ending in ".a" or beginning with "-l" or
  "-L".

If a particular platform requires a special library on your platform,
you can add it by editing the "Setup" file and running "python
setup.py build". For example, if the module defined by the line

   foo foomodule.c

must be linked with the math library "libm.a" on your platform, simply
add "-lm" to the line:

   foo foomodule.c -lm

Arbitrary switches intended for the compiler or the linker can be
supplied with the "-Xcompiler" *arg* and "-Xlinker" *arg* options:

   foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm

The next option after "-Xcompiler" and "-Xlinker" will be appended to
the proper command line, so in the above example the compiler will be
passed the "-o32" option, and the linker will be passed "-shared".  If
a compiler option requires an argument, you’ll have to supply multiple
"-Xcompiler" options; for example, to pass "-x c++" the "Setup" file
would have to contain "-Xcompiler -x -Xcompiler c++".

Compiler flags can also be supplied through setting the "CFLAGS"
environment variable.  If set, the contents of "CFLAGS" will be added
to the compiler flags specified in the  "Setup" file.


Using non-Microsoft compilers on Windows
----------------------------------------


Borland/CodeGear C++
~~~~~~~~~~~~~~~~~~~~

This subsection describes the necessary steps to use Distutils with
the Borland C++ compiler version 5.5.  First you have to know that
Borland’s object file format (OMF) is different from the format used
by the Python version you can download from the Python or ActiveState
Web site.  (Python is built with Microsoft Visual C++, which uses COFF
as the object file format.) For this reason you have to convert
Python’s library "python25.lib" into the Borland format.  You can do
this as follows:

   coff2omf python25.lib python25_bcpp.lib

The "coff2omf" program comes with the Borland compiler.  The file
"python25.lib" is in the "Libs" directory of your Python installation.
If your extension uses other libraries (zlib, …) you have to convert
them too.

The converted files have to reside in the same directories as the
normal libraries.

How does Distutils manage to use these libraries with their changed
names?  If the extension needs a library (eg. "foo") Distutils checks
first if it finds a library with suffix "_bcpp" (eg. "foo_bcpp.lib")
and then uses this library.  In the case it doesn’t find such a
special library it uses the default name ("foo.lib".) [1]

To let Distutils compile your extension with Borland C++ you now have
to type:

   python setup.py build --compiler=bcpp

If you want to use the Borland C++ compiler as the default, you could
specify this in your personal or system-wide configuration file for
Distutils (see section Distutils Configuration Files.)

Voir aussi:

  C++Builder Compiler
     Information about the free C++ compiler from Borland, including
     links to the download pages.

  Creating Python Extensions Using Borland’s Free Compiler
     Document describing how to use Borland’s free command-line C++
     compiler to build Python.


GNU C / Cygwin / MinGW
~~~~~~~~~~~~~~~~~~~~~~

This section describes the necessary steps to use Distutils with the
GNU C/C++ compilers in their Cygwin and MinGW distributions. [2] For a
Python interpreter that was built with Cygwin, everything should work
without any of these following steps.

Not all extensions can be built with MinGW or Cygwin, but many can.
Extensions most likely to not work are those that use C++ or depend on
Microsoft Visual C extensions.

To let Distutils compile your extension with Cygwin you have to type:

   python setup.py build --compiler=cygwin

and for Cygwin in no-cygwin mode [3] or for MinGW type:

   python setup.py build --compiler=mingw32

If you want to use any of these options/compilers as default, you
should consider writing it in your personal or system-wide
configuration file for Distutils (see section Distutils Configuration
Files.)


Older Versions of Python and MinGW
""""""""""""""""""""""""""""""""""

The following instructions only apply if you’re using a version of
Python inferior to 2.4.1 with a MinGW inferior to 3.0.0 (with
binutils-2.13.90-20030111-1).

These compilers require some special libraries.  This task is more
complex than for Borland’s C++, because there is no program to convert
the library.  First you have to create a list of symbols which the
Python DLL exports. (You can find a good program for this task at htt
ps://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/).

   pexports python25.dll >python25.def

The location of an installed "python25.dll" will depend on the
installation options and the version and language of Windows.  In a «
just for me » installation, it will appear in the root of the
installation directory.  In a shared installation, it will be located
in the system directory.

Then you can create from these information an import library for gcc.

   /cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a

The resulting library has to be placed in the same directory as
"python25.lib". (Should be the "libs" directory under your Python
installation directory.)

If your extension uses other libraries (zlib,…) you might  have to
convert them too. The converted files have to reside in the same
directories as the normal libraries do.

Voir aussi:

  Building Python modules on MS Windows platform with MinGW
     Information about building the required libraries for the MinGW
     environment.

-[ Notes ]-

[1] This also means you could replace all existing COFF-libraries
    with OMF-libraries of the same name.

[2] Check https://www.sourceware.org/cygwin/ and
    http://www.mingw.org/ for more information

[3] Then you have no POSIX emulation available, but you also don’t
    need "cygwin1.dll".

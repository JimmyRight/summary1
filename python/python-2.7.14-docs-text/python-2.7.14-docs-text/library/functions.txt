Fonctions Natives
*****************

The Python interpreter has a number of functions built into it that
are always available.  They are listed here in alphabetical order.

+---------------------+-------------------+--------------------+-------------------+----------------------+
|                     |                   | Fonctions Natives  |                   |                      |
+=====================+===================+====================+===================+======================+
| "abs()"             | "divmod()"        | "input()"          | "open()"          | "staticmethod()"     |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "all()"             | "enumerate()"     | "int()"            | "ord()"           | "str()"              |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "any()"             | "eval()"          | "isinstance()"     | "pow()"           | "sum()"              |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "basestring()"      | "execfile()"      | "issubclass()"     | "print()"         | "super()"            |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "bin()"             | "file()"          | "iter()"           | "property()"      | "tuple()"            |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "bool()"            | "filter()"        | "len()"            | "range()"         | "type()"             |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "bytearray()"       | "float()"         | "list()"           | "raw_input()"     | "unichr()"           |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "callable()"        | "format()"        | "locals()"         | "reduce()"        | "unicode()"          |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "chr()"             | "frozenset()"     | "long()"           | "reload()"        | "vars()"             |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "classmethod()"     | "getattr()"       | "map()"            | "repr()"          | "xrange()"           |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "cmp()"             | "globals()"       | "max()"            | "reversed()"      | "zip()"              |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "compile()"         | "hasattr()"       | "memoryview()"     | "round()"         | "__import__()"       |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "complex()"         | "hash()"          | "min()"            | "set()"           |                      |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "delattr()"         | "help()"          | "next()"           | "setattr()"       |                      |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "dict()"            | "hex()"           | "object()"         | "slice()"         |                      |
+---------------------+-------------------+--------------------+-------------------+----------------------+
| "dir()"             | "id()"            | "oct()"            | "sorted()"        |                      |
+---------------------+-------------------+--------------------+-------------------+----------------------+

In addition, there are other four built-in functions that are no
longer considered essential: "apply()", "buffer()", "coerce()", and
"intern()".  They are documented in the Non-essential Built-in
Functions section.

abs(x)

   Return the absolute value of a number.  The argument may be a plain
   or long integer or a floating point number.  If the argument is a
   complex number, its magnitude is returned.

all(iterable)

   Donne "True" si tous les éléments de *iterable* sont vrais (ou s’il
   est vide), équivaut à :

      def all(iterable):
          for element in iterable:
              if not element:
                  return False
          return True

   Nouveau dans la version 2.5.

any(iterable)

   Donne "True" si au moins un élément de *iterable* est vrai. Faux
   est aussi donné dans le cas où *iterable* est vide, équivaut à :

      def any(iterable):
          for element in iterable:
              if element:
                  return True
          return False

   Nouveau dans la version 2.5.

basestring()

   This abstract type is the superclass for "str" and "unicode". It
   cannot be called or instantiated, but it can be used to test
   whether an object is an instance of "str" or "unicode".
   "isinstance(obj, basestring)" is equivalent to "isinstance(obj,
   (str, unicode))".

   Nouveau dans la version 2.3.

bin(x)

   Convert an integer number to a binary string. The result is a valid
   Python expression.  If *x* is not a Python "int" object, it has to
   define an "__index__()" method that returns an integer.

   Nouveau dans la version 2.6.

class bool([x])

   Return a Boolean value, i.e. one of "True" or "False".  *x* is
   converted using the standard truth testing procedure.  If *x* is
   false or omitted, this returns "False"; otherwise it returns
   "True". "bool" is also a class, which is a subclass of "int". Class
   "bool" cannot be subclassed further.  Its only instances are
   "False" and "True".

   Nouveau dans la version 2.2.1.

   Modifié dans la version 2.3: If no argument is given, this function
   returns "False".

class bytearray([source[, encoding[, errors]]])

   Return a new array of bytes.  The "bytearray" class is a mutable
   sequence of integers in the range 0 <= x < 256.  It has most of the
   usual methods of mutable sequences, described in Types de séquences
   mutables, as well as most methods that the "str" type has, see
   Méthodes de chaînes de caractères.

   Le paramètre optionnel *source* peut être utilisé pour initialiser
   l”*array* de quelques manières différentes :

   * If it is *unicode*, you must also give the *encoding* (and
     optionally, *errors*) parameters; "bytearray()" then converts the
     unicode to bytes using "unicode.encode()".

   * Si c’est un *entier*, l”*array* aura cette taille et sera
     initialisé de *null bytes*.

   * Si c’est un objet conforme à l’interface *buffer*, un *buffer*
     en lecture seule de l’objet sera utilisé pour initialiser
     l”*array*.

   * Si c’est un *itérable*, il doit itérer sur des nombres entier
     dans l’intervalle "0 <= x < 256", qui seront utilisés pour
     initialiser le contenu de l”*array*.

   Sans argument, un *array* de taille vide est crée.

   Nouveau dans la version 2.6.

callable(object)

   Return "True" if the *object* argument appears callable, "False" if
   not.  If this returns true, it is still possible that a call fails,
   but if it is false, calling *object* will never succeed.  Note that
   classes are callable (calling a class returns a new instance);
   class instances are callable if they have a "__call__()" method.

chr(i)

   Return a string of one character whose ASCII code is the integer
   *i*.  For example, "chr(97)" returns the string "'a'". This is the
   inverse of "ord()".  The argument must be in the range [0..255],
   inclusive; "ValueError" will be raised if *i* is outside that
   range. See also "unichr()".

classmethod(function)

   Donne une méthode de classe pour *fonction*.

   Une méthode de classe reçoit implicitement la classe en premier
   augment, tout comme une méthode d’instance reçoit l’instance. Voici
   comment déclarer une méthode de classe :

      class C(object):
          @classmethod
          def f(cls, arg1, arg2, ...):
              ...

   La forme "@classmethod" est un *decorator* – consultez la
   documentation sur la définition de fonctions dans Function
   definitions pour plus de détails.

   Elle peut être appelée soit sur la classe (comme "C.f()") ou sur
   une instance (comme "C().f()"). L’instance est ignorée, sauf pour
   déterminer sa classe. Si la méthode est appelée sur une instance de
   classe fille, c’est la classe fille qui sera donnée en premier
   argument implicite.

   Les méthodes de classe sont différentes des méthodes statiques du
   C++ ou du Java. Si c’est elles sont vous avez besoin, regardez du
   côté de "staticmethod()".

   Pour plus d’informations sur les méthodes de classe, consultez la
   documentation sur la hiérarchie des types standards dans The
   standard type hierarchy.

   Nouveau dans la version 2.2.

   Modifié dans la version 2.4: Function decorator syntax added.

cmp(x, y)

   Compare the two objects *x* and *y* and return an integer according
   to the outcome.  The return value is negative if "x < y", zero if
   "x == y" and strictly positive if "x > y".

compile(source, filename, mode[, flags[, dont_inherit]])

   Compile the *source* into a code or AST object.  Code objects can
   be executed by an "exec" statement or evaluated by a call to
   "eval()". *source* can either be a Unicode string, a *Latin-1*
   encoded string or an AST object. Refer to the "ast" module
   documentation for information on how to work with AST objects.

   L’argument *filename* doit nommer le fichier duquel le code à été
   lu. Donnez quelque chose de reconnaissable lorsqu’il n’a pas été lu
   depuis un fichier (typiquement ""<string>"").

   L’argument *mode* indique quel type de code doit être compilé :
   "'exec'" si source est une suite d’instructions, "'eval'" pour une
   seule expression, ou "'single'" si il ne contient qu’une
   instruction interactive (dans ce dernier cas, les résultats
   d’expressions donnant autre chose que "None" seront affichés).

   Les arguments optionnels *flags* et *dont_inherit* contrôlent
   quelle instructions *future* (voir **PEP 236**) affecte la
   compilation de *source*. Si aucun des deux n’est présent (ou que
   les deux sont à 0) le code est compilé avec les mêmes instructions
   *future* que le code appelant "compile()". Si l’argument *flags*
   est fourni mais que *dont_inherit* ne l’est pas (ou vaut 0), alors
   les instructions *futures* utilisées seront celles spécifiées par
   *flags* en plus de celles qui auraient été utilisées. Si
   *dont_inherit* est un entier différent de zéro, *flags* est utilisé
   seul – les instructions futures déclarées autour de l’appel à
   *compile* sont ignorées.

   Les instructions futures sont spécifiées par des bits, il est ainsi
   possible d’en spécifier plusieurs en les combinant avec un *ou*
   binaire. Les bits requis pour spécifier une certaine fonctionnalité
   se trouvent dans l’attribut "compiler_flag" de la classe "Feature"
   du module "__future__".

   This function raises "SyntaxError" if the compiled source is
   invalid, and "TypeError" if the source contains null bytes.

   Si vous voulez transformer du code Python en sa représentation AST,
   voyez "ast.parse()".

   Note: Lors de la compilation d’une chaîne de plusieurs lignes de
     code avec les modes "'single'" ou "'eval'", celle-ci doit être
     terminée d’au moins un retour à la ligne. Cela permet de
     faciliter la distinction entre les instructions complètes et
     incomplètes dans le module "code".

   Modifié dans la version 2.3: The *flags* and *dont_inherit*
   arguments were added.

   Modifié dans la version 2.6: Support for compiling AST objects.

   Modifié dans la version 2.7: Allowed use of Windows and Mac
   newlines.  Also input in "'exec'" mode does not have to end in a
   newline anymore.

class complex([real[, imag]])

   Return a complex number with the value *real* + *imag**1j or
   convert a string or number to a complex number.  If the first
   parameter is a string, it will be interpreted as a complex number
   and the function must be called without a second parameter.  The
   second parameter can never be a string. Each argument may be any
   numeric type (including complex). If *imag* is omitted, it defaults
   to zero and the function serves as a numeric conversion function
   like "int()", "long()" and "float()".  If both arguments are
   omitted, returns "0j".

   Note: Lors de la conversion depuis une chaîne, elle ne doit pas
     contenir d’espaces autour des opérateurs binaires "+" ou "-". Par
     exemple "complex('1+2j')" est bon, mais "complex('1 + 2j')" lève
     une "ValueError".

   Le type complexe est décrit dans Numeric Types — int, float, long,
   complex.

delattr(object, name)

   C’est un cousin de "setattr()". Les arguments sont un objet et une
   chaîne. La chaîne doit être le nom de l’un des attributs de
   l’objet. La fonction supprime l’attribut nommé, si l’objet l’y
   autorise. Par exemple "delattr(x, 'foobar')" est l’équivalent de
   "del x.foobar".

class dict(**kwarg)
class dict(mapping, **kwarg)
class dict(iterable, **kwarg)

   Créé un nouveau dictionnaire. L’objet "dict" est la classe du
   dictionnaire. Voir "dict" et Les types de correspondances — dict
   pour vous documenter sur cette classe.

   Pour les autres conteneurs, voir les classes natives "list", "set",
   et "typle". ainsi que le module "collections".

dir([object])

   Sans arguments, elle donne la liste des noms dans l’espace de noms
   local. Avec un argument, elle essaye de donner une liste
   d’attributs valides pour cet objet.

   Si l’objet à une méthode "__dir__()", elle est appelée et doit
   donner une liste d’attributs. Cela permet aux objets implémentant
   "__getattr__()" ou "__getattribute__()" de personnaliser ce que
   donnera "dir()".

   Si l’objet ne fournit pas de méthode "__dir__()", la fonction fait
   de son mieux en rassemblant les informations de l’attribut
   "__dict__" de l’objet, si défini, et depuis son type. La liste
   résultante n’est pas nécessairement complète, et peut être
   inadaptée quand l’objet a un "__getattr__()" personnalisé.

   Le mécanisme par défaut de "dir()" se comporte différemment avec
   différents types d’objets, car elle préfère donner une information
   pertinente plutôt qu’exhaustive :

   * Si l’objet est un module, la liste contiendra les noms des
     attributs du module.

   * Si l’objet est un type ou une classe, la liste contiendra les
     noms de ses attributs, et récursivement, des attributs de ses
     parents.

   * Autrement, la liste contient les noms des attributs de l’objet,
     le nom des attributs de la classe, et récursivement des attributs
     des parents de la classe.

   La liste donnée est triée par ordre alphabétique, par exemple :

   >>> import struct
   >>> dir()   # show the names in the module namespace
   ['__builtins__', '__doc__', '__name__', 'struct']
   >>> dir(struct)   # show the names in the struct module
   ['Struct', '__builtins__', '__doc__', '__file__', '__name__',
    '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
    'unpack', 'unpack_from']
   >>> class Shape(object):
           def __dir__(self):
               return ['area', 'perimeter', 'location']
   >>> s = Shape()
   >>> dir(s)
   ['area', 'perimeter', 'location']

   Note: Étant donné que "dir()" est d’abord fournie pour son côté
     pratique en mode interactif, elle a tendance à fournir un jeu
     intéressant de noms plutôt qu’un ensemble consistant et
     rigoureusement défini, son comportement peut aussi changer d’une
     version à l’autre. Par exemple, les attributs de méta-classes ne
     sont pas données lorsque l’argument est une classe.

divmod(a, b)

   Take two (non complex) numbers as arguments and return a pair of
   numbers consisting of their quotient and remainder when using long
   division.  With mixed operand types, the rules for binary
   arithmetic operators apply.  For plain and long integers, the
   result is the same as "(a // b, a % b)". For floating point numbers
   the result is "(q, a % b)", where *q* is usually "math.floor(a /
   b)" but may be 1 less than that.  In any case "q * b + a % b" is
   very close to *a*, if "a % b" is non-zero it has the same sign as
   *b*, and "0 <= abs(a % b) < abs(b)".

   Modifié dans la version 2.3: Using "divmod()" with complex numbers
   is deprecated.

enumerate(sequence, start=0)

   Return an enumerate object. *sequence* must be a sequence, an
   *iterator*, or some other object which supports iteration.  The
   "next()" method of the iterator returned by "enumerate()" returns a
   tuple containing a count (from *start* which defaults to 0) and the
   values obtained from iterating over *sequence*:

      >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
      >>> list(enumerate(seasons))
      [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
      >>> list(enumerate(seasons, start=1))
      [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

   Équivalent à :

      def enumerate(sequence, start=0):
          n = start
          for elem in sequence:
              yield n, elem
              n += 1

   Nouveau dans la version 2.3.

   Modifié dans la version 2.6: The *start* parameter was added.

eval(expression[, globals[, locals]])

   The arguments are a Unicode or *Latin-1* encoded string and
   optional globals and locals.  If provided, *globals* must be a
   dictionary. If provided, *locals* can be any mapping object.

   Modifié dans la version 2.4: formerly *locals* was required to be a
   dictionary.

   The *expression* argument is parsed and evaluated as a Python
   expression (technically speaking, a condition list) using the
   *globals* and *locals* dictionaries as global and local namespace.
   If the *globals* dictionary is present and lacks “__builtins__”,
   the current globals are copied into *globals* before *expression*
   is parsed.  This means that *expression* normally has full access
   to the standard "__builtin__" module and restricted environments
   are propagated.  If the *locals* dictionary is omitted it defaults
   to the *globals* dictionary.  If both dictionaries are omitted, the
   expression is executed in the environment where "eval()" is called.
   The return value is the result of the evaluated expression. Syntax
   errors are reported as exceptions.  Example:

   >>> x = 1
   >>> print eval('x+1')
   2

   Cette fonction peut aussi être utilisée pour exécuter n’importe
   quel objet code (tel que ceux créés par "compile()"). Dans ce cas,
   donnez un objet code plutôt qu’une chaîne. Si l’objet code à été
   compilé avec "'exec'" en argument pour *mode*, "eval()" donnera
   "None".

   Hints: dynamic execution of statements is supported by the "exec"
   statement.  Execution of statements from a file is supported by the
   "execfile()" function.  The "globals()" and "locals()" functions
   returns the current global and local dictionary, respectively,
   which may be useful to pass around for use by "eval()" or
   "execfile()".

   Utilisez "ast.literal_eval()" si vous avez besoin d’une fonction
   qui peut évaluer en toute sécurité des chaînes avec des expressions
   ne contenant que des valeurs littérales.

execfile(filename[, globals[, locals]])

   This function is similar to the "exec" statement, but parses a file
   instead of a string.  It is different from the "import" statement
   in that it does not use the module administration — it reads the
   file unconditionally and does not create a new module. [1]

   The arguments are a file name and two optional dictionaries.  The
   file is parsed and evaluated as a sequence of Python statements
   (similarly to a module) using the *globals* and *locals*
   dictionaries as global and local namespace. If provided, *locals*
   can be any mapping object.  Remember that at module level, globals
   and locals are the same dictionary. If two separate objects are
   passed as *globals* and *locals*, the code will be executed as if
   it were embedded in a class definition.

   Modifié dans la version 2.4: formerly *locals* was required to be a
   dictionary.

   If the *locals* dictionary is omitted it defaults to the *globals*
   dictionary. If both dictionaries are omitted, the expression is
   executed in the environment where "execfile()" is called.  The
   return value is "None".

   Note: The default *locals* act as described for function
     "locals()" below: modifications to the default *locals*
     dictionary should not be attempted.  Pass an explicit *locals*
     dictionary if you need to see effects of the code on *locals*
     after function "execfile()" returns.  "execfile()" cannot be used
     reliably to modify a function’s locals.

file(name[, mode[, buffering]])

   Constructor function for the "file" type, described further in
   section File Objects.  The constructor’s arguments are the same as
   those of the "open()" built-in function described below.

   When opening a file, it’s preferable to use "open()" instead of
   invoking this constructor directly.  "file" is more suited to type
   testing (for example, writing "isinstance(f, file)").

   Nouveau dans la version 2.2.

filter(function, iterable)

   Construct a list from those elements of *iterable* for which
   *function* returns true.  *iterable* may be either a sequence, a
   container which supports iteration, or an iterator.  If *iterable*
   is a string or a tuple, the result also has that type; otherwise it
   is always a list.  If *function* is "None", the identity function
   is assumed, that is, all elements of *iterable* that are false are
   removed.

   Note that "filter(function, iterable)" is equivalent to "[item for
   item in iterable if function(item)]" if function is not "None" and
   "[item for item in iterable if item]" if function is "None".

   See "itertools.ifilter()" and "itertools.ifilterfalse()" for
   iterator versions of this function, including a variation that
   filters for elements where the *function* returns false.

class float([x])

   Donne un nombre a virgule flottante depuis un nombre ou une chaîne
   *x*.

   If the argument is a string, it must contain a possibly signed
   decimal or floating point number, possibly embedded in whitespace.
   The argument may also be [+|-]nan or [+|-]inf. Otherwise, the
   argument may be a plain or long integer or a floating point number,
   and a floating point number with the same value (within Python’s
   floating point precision) is returned.  If no argument is given,
   returns "0.0".

   Note: When passing in a string, values for NaN and Infinity may
     be returned, depending on the underlying C library.  Float
     accepts the strings nan, inf and -inf for NaN and positive or
     negative infinity. The case and a leading + are ignored as well
     as a leading - is ignored for NaN. Float always represents NaN
     and infinity as nan, inf or -inf.

   Le type *float* est décrit dans Numeric Types — int, float, long,
   complex.

format(value[, format_spec])

   Convertit une valeur en sa représentation « formatée », tel que
   décrit par *format_spec*. L’interprétation de *format_spec* dépend
   du type de la valeur, cependant il existe une syntaxe standard
   utilisée par la plupart des types natifs : Mini-langage de
   spécification de format.

   Note: "format(value, format_spec)" merely calls
     "value.__format__(format_spec)".

   Nouveau dans la version 2.6.

class frozenset([iterable])

   Donne un nouveau "frozenset", dont les objets sont éventuellement
   tirés d”*iterable*. "frozenset" est une classe native. Voir
   "frozenset" et Types d’ensembles — set, frozenset pour leurs
   documentation.

   Pour d’autres conteneurs, voyez les classes natives "set", "list",
   "tuple", et "dict", ainsi que le module "collections".

   Nouveau dans la version 2.4.

getattr(object, name[, default])

   Donne la valeur de l’attribut nommé *name* de l’objet *object*.
   *name* doit être une chaîne. Si la chaîne est le nom d’un des
   attributs de l’objet, le résultat est la valeur de cet attribut.
   Par exemple, "getattr(x, 'foobar')" est équivalent à "x.foobar". Si
   l’attribut n’existe pas, et que *default* est fourni, il est
   renvoyé, sinon l’exception "AttributeError" est levée.

globals()

   Donne une représentation de la table de symboles globaux sous forme
   d’un dictionnaire. C’est toujours le dictionnaire du module courant
   (dans une fonction ou méthode, c’est le module où elle est définie,
   et non le module d’où elle est appelée).

hasattr(object, name)

   The arguments are an object and a string.  The result is "True" if
   the string is the name of one of the object’s attributes, "False"
   if not. (This is implemented by calling "getattr(object, name)" and
   seeing whether it raises an exception or not.)

hash(object)

   Return the hash value of the object (if it has one).  Hash values
   are integers. They are used to quickly compare dictionary keys
   during a dictionary lookup. Numeric values that compare equal have
   the same hash value (even if they are of different types, as is the
   case for 1 and 1.0).

help([object])

   Invoque le système d’aide natif. (Cette fonction est destinée à
   l’usage en mode interactif.) Soi aucun argument n’est fourni, le
   système d’aide démarre dans l’interpréteur. Si l’argument est une
   chaîne, un module, une fonction, une classe, une méthode, un mot
   clef, ou un sujet de documentation pourtant ce nom est recherché,
   et une page d’aide est affichée sur la console. Si l’argument est
   d’un autre type, une page d’aide sur cet objet est générée.

   Cette fonction est ajoutée à l’espace de noms natif par le module
   "site".

   Nouveau dans la version 2.2.

hex(x)

   Convert an integer number (of any size) to a lowercase hexadecimal
   string prefixed with « 0x », for example:

   >>> hex(255)
   '0xff'
   >>> hex(-42)
   '-0x2a'
   >>> hex(1L)
   '0x1L'

   If x is not a Python "int" or "long" object, it has to define a
   __hex__() method that returns a string.

   Voir aussi "int()" pour convertir une chaîne hexadécimale en un
   entier en lui spécifiant 16 comme base.

   Note: Pour obtenir une représentation hexadécimale sous forme de
     chaîne d’un nombre à virgule flottante, utilisez la méthode
     "float.hex()".

   Modifié dans la version 2.4: Formerly only returned an unsigned
   literal.

id(object)

   Return the « identity » of an object.  This is an integer (or long
   integer) which is guaranteed to be unique and constant for this
   object during its lifetime. Two objects with non-overlapping
   lifetimes may have the same "id()" value.

   **CPython implementation detail:** This is the address of the
   object in memory.

input([prompt])

   Equivalent to "eval(raw_input(prompt))".

   This function does not catch user errors. If the input is not
   syntactically valid, a "SyntaxError" will be raised. Other
   exceptions may be raised if there is an error during evaluation.

   Si le module "readline" est chargé, "input()" l’utilisera pour
   fournir des fonctionnalités d’édition et d’historique élaborées.

   Consider using the "raw_input()" function for general input from
   users.

class int(x=0)
class int(x, base=10)

   Return an integer object constructed from a number or string *x*,
   or return "0" if no arguments are given.  If *x* is a number, it
   can be a plain integer, a long integer, or a floating point number.
   If *x* is floating point, the conversion truncates towards zero.
   If the argument is outside the integer range, the function returns
   a long object instead.

   If *x* is not a number or if *base* is given, then *x* must be a
   string or Unicode object representing an integer literal in radix
   *base*.  Optionally, the literal can be preceded by "+" or "-"
   (with no space in between) and surrounded by whitespace.  A base-n
   literal consists of the digits 0 to n-1, with "a" to "z" (or "A" to
   "Z") having values 10 to 35.  The default *base* is 10. The allowed
   values are 0 and 2–36. Base-2, -8, and -16 literals can be
   optionally prefixed with "0b"/"0B", "0o"/"0O"/"0", or "0x"/"0X", as
   with integer literals in code. Base 0 means to interpret the string
   exactly as an integer literal, so that the actual base is 2, 8, 10,
   or 16.

   Le type des entiers est décrit dans Numeric Types — int, float,
   long, complex.

isinstance(object, classinfo)

   Return true if the *object* argument is an instance of the
   *classinfo* argument, or of a (direct, indirect or *virtual*)
   subclass thereof.  Also return true if *classinfo* is a type object
   (new-style class) and *object* is an object of that type or of a
   (direct, indirect or *virtual*) subclass thereof.  If *object* is
   not a class instance or an object of the given type, the function
   always returns false. If *classinfo* is a tuple of class or type
   objects (or recursively, other such tuples), return true if
   *object* is an instance of any of the classes or types.  If
   *classinfo* is not a class, type, or tuple of classes, types, and
   such tuples, a "TypeError" exception is raised.

   Modifié dans la version 2.2: Support for a tuple of type
   information was added.

issubclass(class, classinfo)

   Donne "True" si *class* est une classe fille (directe, indirecte,
   ou *virtual*) de *classinfo*. Une classe est considérée sous-classe
   d’elle même. *classinfo* peut être un tuple de classes, dans ce cas
   la vérification sera faite pour chaque classe de *classinfo*. Dans
   tous les autres cas, "TypeError" est levée.

   Modifié dans la version 2.3: Support for a tuple of type
   information was added.

iter(o[, sentinel])

   Return an *iterator* object.  The first argument is interpreted
   very differently depending on the presence of the second argument.
   Without a second argument, *o* must be a collection object which
   supports the iteration protocol (the "__iter__()" method), or it
   must support the sequence protocol (the "__getitem__()" method with
   integer arguments starting at "0").  If it does not support either
   of those protocols, "TypeError" is raised. If the second argument,
   *sentinel*, is given, then *o* must be a callable object.  The
   iterator created in this case will call *o* with no arguments for
   each call to its "next()" method; if the value returned is equal to
   *sentinel*, "StopIteration" will be raised, otherwise the value
   will be returned.

   Une autre application utile de la deuxième forme de "iter()" est de
   lire les lignes d’un fichier jusqu’à ce qu’un certaine ligne soit
   atteinte. L’exemple suivant lis un fichier jusqu’à ce que
   "readline()" donne une ligne vide :

      with open('mydata.txt') as fp:
          for line in iter(fp.readline, ''):
              process_line(line)

   Nouveau dans la version 2.2.

len(s)

   Donne la longueur (nombre d’éléments) d’un objet. L’argument peut
   être une séquence (tel qu’une chaîne, un objet  "bytes", "tuple",
   "list" ou "range") ou une collection (tel qu’un "dict", "set" ou
   "frozenset").

class list([iterable])

   Return a list whose items are the same and in the same order as
   *iterable*’s items.  *iterable* may be either a sequence, a
   container that supports iteration, or an iterator object.  If
   *iterable* is already a list, a copy is made and returned, similar
   to "iterable[:]".  For instance, "list('abc')" returns "['a', 'b',
   'c']" and "list( (1, 2, 3) )" returns "[1, 2, 3]".  If no argument
   is given, returns a new empty list, "[]".

   "list" is a mutable sequence type, as documented in Sequence Types
   — str, unicode, list, tuple, bytearray, buffer, xrange. For other
   containers see the built in "dict", "set", and "tuple" classes, and
   the "collections" module.

locals()

   Met à jour et donne un dictionnaire représentant la table des
   symboles locaux. Les variables libres sont données par "locals()"
   lorsqu’elle est appelée dans le corps d’une fonction, mais pas dans
   le corps d’une classe.

   Note: Le contenu de ce dictionnaire ne devrait pas être modifié,
     les changements peuvent ne pas affecter les valeurs des variables
     locales ou libres utilisées par l’interpréteur.

class long(x=0)
class long(x, base=10)

   Return a long integer object constructed from a string or number
   *x*. If the argument is a string, it must contain a possibly signed
   number of arbitrary size, possibly embedded in whitespace. The
   *base* argument is interpreted in the same way as for "int()", and
   may only be given when *x* is a string. Otherwise, the argument may
   be a plain or long integer or a floating point number, and a long
   integer with the same value is returned.    Conversion of floating
   point numbers to integers truncates (towards zero).  If no
   arguments are given, returns "0L".

   The long type is described in Numeric Types — int, float, long,
   complex.

map(function, iterable, …)

   Apply *function* to every item of *iterable* and return a list of
   the results. If additional *iterable* arguments are passed,
   *function* must take that many arguments and is applied to the
   items from all iterables in parallel.  If one iterable is shorter
   than another it is assumed to be extended with "None" items.  If
   *function* is "None", the identity function is assumed; if there
   are multiple arguments, "map()" returns a list consisting of tuples
   containing the corresponding items from all iterables (a kind of
   transpose operation).  The *iterable* arguments may be a sequence
   or any iterable object; the result is always a list.

max(iterable[, key])
max(arg1, arg2, *args[, key])

   Donne l’élément le plus grand dans un iterable, ou l’argument le
   plus grand parmi au moins deux arguments.

   If one positional argument is provided, *iterable* must be a non-
   empty iterable (such as a non-empty string, tuple or list).  The
   largest item in the iterable is returned.  If two or more
   positional arguments are provided, the largest of the positional
   arguments is returned.

   The optional *key* argument specifies a one-argument ordering
   function like that used for "list.sort()".  The *key* argument, if
   supplied, must be in keyword form (for example,
   "max(a,b,c,key=func)").

   Modifié dans la version 2.5: Added support for the optional *key*
   argument.

memoryview(obj)

   Donne une « vue mémoire » (*memory view*) créée depuis l’argument.
   Voir memoryview type pour plus d’informations.

min(iterable[, key])
min(arg1, arg2, *args[, key])

   Donne le plus petit élément d’un itérable ou le plus petit d’au
   moins deux arguments.

   If one positional argument is provided, *iterable* must be a non-
   empty iterable (such as a non-empty string, tuple or list).  The
   smallest item in the iterable is returned.  If two or more
   positional arguments are provided, the smallest of the positional
   arguments is returned.

   The optional *key* argument specifies a one-argument ordering
   function like that used for "list.sort()".  The *key* argument, if
   supplied, must be in keyword form (for example,
   "min(a,b,c,key=func)").

   Modifié dans la version 2.5: Added support for the optional *key*
   argument.

next(iterator[, default])

   Retrieve the next item from the *iterator* by calling its "next()"
   method.  If *default* is given, it is returned if the iterator is
   exhausted, otherwise "StopIteration" is raised.

   Nouveau dans la version 2.6.

class object

   Return a new featureless object.  "object" is a base for all new
   style classes.  It has the methods that are common to all instances
   of new style classes.

   Nouveau dans la version 2.2.

   Modifié dans la version 2.3: This function does not accept any
   arguments. Formerly, it accepted arguments but ignored them.

oct(x)

   Convert an integer number (of any size) to an octal string.  The
   result is a valid Python expression.

   Modifié dans la version 2.4: Formerly only returned an unsigned
   literal.

open(name[, mode[, buffering]])

   Open a file, returning an object of the "file" type described in
   section File Objects.  If the file cannot be opened, "IOError" is
   raised.  When opening a file, it’s preferable to use "open()"
   instead of invoking the "file" constructor directly.

   The first two arguments are the same as for "stdio"’s "fopen()":
   *name* is the file name to be opened, and *mode* is a string
   indicating how the file is to be opened.

   The most commonly-used values of *mode* are "'r'" for reading,
   "'w'" for writing (truncating the file if it already exists), and
   "'a'" for appending (which on *some* Unix systems means that *all*
   writes append to the end of the file regardless of the current seek
   position).  If *mode* is omitted, it defaults to "'r'".  The
   default is to use text mode, which may convert "'\n'" characters to
   a platform-specific representation on writing and back on reading.
   Thus, when opening a binary file, you should append "'b'" to the
   *mode* value to open the file in binary mode, which will improve
   portability.  (Appending "'b'" is useful even on systems that don’t
   treat binary and text files differently, where it serves as
   documentation.)  See below for more possible values of *mode*.

   The optional *buffering* argument specifies the file’s desired
   buffer size: 0 means unbuffered, 1 means line buffered, any other
   positive value means use a buffer of (approximately) that size (in
   bytes).  A negative *buffering* means to use the system default,
   which is usually line buffered for tty devices and fully buffered
   for other files.  If omitted, the system default is used. [2]

   Modes "'r+'", "'w+'" and "'a+'" open the file for updating (reading
   and writing); note that "'w+'" truncates the file.  Append "'b'" to
   the mode to open the file in binary mode, on systems that
   differentiate between binary and text files; on systems that don’t
   have this distinction, adding the "'b'" has no effect.

   In addition to the standard "fopen()" values *mode* may be "'U'" or
   "'rU'".  Python is usually built with *universal newlines* support;
   supplying "'U'" opens the file as a text file, but lines may be
   terminated by any of the following: the Unix end-of-line convention
   "'\n'",  the Macintosh convention "'\r'", or the Windows convention
   "'\r\n'". All of these external representations are seen as "'\n'"
   by the Python program. If Python is built without universal
   newlines support a *mode* with "'U'" is the same as normal text
   mode.  Note that file objects so opened also have an attribute
   called "newlines" which has a value of "None" (if no newlines have
   yet been seen), "'\n'", "'\r'", "'\r\n'", or a tuple containing all
   the newline types seen.

   Python enforces that the mode, after stripping "'U'", begins with
   "'r'", "'w'" or "'a'".

   Python provides many file handling modules including "fileinput",
   "os", "os.path", "tempfile", and "shutil".

   Modifié dans la version 2.5: Restriction on first letter of mode
   string introduced.

ord(c)

   Given a string of length one, return an integer representing the
   Unicode code point of the character when the argument is a unicode
   object, or the value of the byte when the argument is an 8-bit
   string. For example, "ord('a')" returns the integer "97",
   "ord(u'\u2020')" returns "8224".  This is the inverse of "chr()"
   for 8-bit strings and of "unichr()" for unicode objects.  If a
   unicode argument is given and Python was built with UCS2 Unicode,
   then the character’s code point must be in the range [0..65535]
   inclusive; otherwise the string length is two, and a "TypeError"
   will be raised.

pow(x, y[, z])

   Donne *x* puissance *y*, et si *z* est présent, donne *x* puissance
   *y* modulo *z* (calculé de manière plus efficiente que "pow(x, y) %
   z"). La forme à deux arguments est équivalent à "x**y".

   The arguments must have numeric types.  With mixed operand types,
   the coercion rules for binary arithmetic operators apply.  For int
   and long int operands, the result has the same type as the operands
   (after coercion) unless the second argument is negative; in that
   case, all arguments are converted to float and a float result is
   delivered.  For example, "10**2" returns "100", but "10**-2"
   returns "0.01".  (This last feature was added in Python 2.2.  In
   Python 2.1 and before, if both arguments were of integer types and
   the second argument was negative, an exception was raised.) If the
   second argument is negative, the third argument must be omitted. If
   *z* is present, *x* and *y* must be of integer types, and *y* must
   be non-negative.  (This restriction was added in Python 2.2.  In
   Python 2.1 and before, floating 3-argument "pow()" returned
   platform-dependent results depending on floating-point rounding
   accidents.)

print(*objects, sep=” “, end=”\n”, file=sys.stdout)

   Print *objects* to the stream *file*, separated by *sep* and
   followed by *end*.  *sep*, *end* and *file*, if present, must be
   given as keyword arguments.

   Tous les arguments positionnels sont convertis en chaîne comme le
   fait "str()", puis écrits sur le flux, séparés par *sep* et
   terminés par *end*. *sep* et *end* doivent être des chaînes, ou
   "None" , indiquant de prendre les valeurs par défaut. Si aucun
   *objects* n’est donné "print()" écris seulement *end*.

   The *file* argument must be an object with a "write(string)"
   method; if it is not present or "None", "sys.stdout" will be used.
   Output buffering is determined by *file*.  Use "file.flush()" to
   ensure, for instance, immediate appearance on a screen.

   Note: This function is not normally available as a built-in since
     the name "print" is recognized as the "print" statement.  To
     disable the statement and use the "print()" function, use this
     future statement at the top of your module:

        from __future__ import print_function

   Nouveau dans la version 2.6.

class property([fget[, fset[, fdel[, doc]]]])

   Return a property attribute for *new-style class*es (classes that
   derive from "object").

   *fget* est une fonction permettant d’obtenir la valeur d’un
   attribut. *fset* est une fonction pour en définir la valeur. *fdel*
   quand à elle permet de supprimer la valeur d’un attribut, et *doc*
   créé une *docstring* pour l’attribut.

   Une utilisation typique : définir un attribut managé "x" :

      class C(object):
          def __init__(self):
              self._x = None

          def getx(self):
              return self._x

          def setx(self, value):
              self._x = value

          def delx(self):
              del self._x

          x = property(getx, setx, delx, "I'm the 'x' property.")

   Si *c* est une instance de *C*, "c.x" appellera le *getter*, "c.x =
   value" invoquera le *setter*, et "del x" le *deleter*.

   S’il est donné, *doc* sera la *docstring* de l’attribut. Autrement
   la propriété copiera celle de *fget* (si elle existe). Cela rend
   possible la création de propriétés en lecture seule en utilisant
   simplement "property()" comme un *decorator* :

      class Parrot(object):
          def __init__(self):
              self._voltage = 100000

          @property
          def voltage(self):
              """Get the current voltage."""
              return self._voltage

   Le décorateur "@property" transforme la méthode "voltage()" en un
   *getter* d’un attribut du même nom, et donne « Get the current
   voltage » comme *docstring* de *voltage*.

   Un objet propriété à les méthodes "getter", "setter" et "deleter"
   utilisables comme décorateurs créant une copie de la propriété avec
   les accesseurs correspondants définis par la fonction de
   décoration. C’est plus clair avec un exemple :

      class C(object):
          def __init__(self):
              self._x = None

          @property
          def x(self):
              """I'm the 'x' property."""
              return self._x

          @x.setter
          def x(self, value):
              self._x = value

          @x.deleter
          def x(self):
              del self._x

   Ce code est l’exact équivalent du premier exemple. Soyez attentifs
   à bien donner aux fonctions additionnelles le même nom que la
   propriété ("x" dans ce cas.)

   L’objet propriété donné à aussi les attributs "fget", "fset" et
   "fdel" correspondant correspondants aux arguments du constructeur.

   Nouveau dans la version 2.2.

   Modifié dans la version 2.5: Use *fget*’s docstring if no *doc*
   given.

   Modifié dans la version 2.6: The "getter", "setter", and "deleter"
   attributes were added.

range(stop)
range(start, stop[, step])

   This is a versatile function to create lists containing arithmetic
   progressions. It is most often used in "for" loops.  The arguments
   must be plain integers.  If the *step* argument is omitted, it
   defaults to "1".  If the *start* argument is omitted, it defaults
   to "0".  The full form returns a list of plain integers "[start,
   start + step, start + 2 * step, ...]".  If *step* is positive, the
   last element is the largest "start + i * step" less than *stop*; if
   *step* is negative, the last element is the smallest "start + i *
   step" greater than *stop*.  *step* must not be zero (or else
   "ValueError" is raised).  Example:

   >>> range(10)
   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   >>> range(1, 11)
   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   >>> range(0, 30, 5)
   [0, 5, 10, 15, 20, 25]
   >>> range(0, 10, 3)
   [0, 3, 6, 9]
   >>> range(0, -10, -1)
   [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
   >>> range(0)
   []
   >>> range(1, 0)
   []

raw_input([prompt])

   If the *prompt* argument is present, it is written to standard
   output without a trailing newline.  The function then reads a line
   from input, converts it to a string (stripping a trailing newline),
   and returns that. When EOF is read, "EOFError" is raised. Example:

      >>> s = raw_input('--> ')
      --> Monty Python's Flying Circus
      >>> s
      "Monty Python's Flying Circus"

   If the "readline" module was loaded, then "raw_input()" will use it
   to provide elaborate line editing and history features.

reduce(function, iterable[, initializer])

   Apply *function* of two arguments cumulatively to the items of
   *iterable*, from left to right, so as to reduce the iterable to a
   single value.  For example, "reduce(lambda x, y: x+y, [1, 2, 3, 4,
   5])" calculates "((((1+2)+3)+4)+5)". The left argument, *x*, is the
   accumulated value and the right argument, *y*, is the update value
   from the *iterable*.  If the optional *initializer* is present, it
   is placed before the items of the iterable in the calculation, and
   serves as a default when the iterable is empty.  If *initializer*
   is not given and *iterable* contains only one item, the first item
   is returned. Roughly equivalent to:

      def reduce(function, iterable, initializer=None):
          it = iter(iterable)
          if initializer is None:
              try:
                  initializer = next(it)
              except StopIteration:
                  raise TypeError('reduce() of empty sequence with no initial value')
          accum_value = initializer
          for x in it:
              accum_value = function(accum_value, x)
          return accum_value

reload(module)

   Reload a previously imported *module*.  The argument must be a
   module object, so it must have been successfully imported before.
   This is useful if you have edited the module source file using an
   external editor and want to try out the new version without leaving
   the Python interpreter.  The return value is the module object (the
   same as the *module* argument).

   When "reload(module)" is executed:

   * Python modules” code is recompiled and the module-level code
     reexecuted, defining a new set of objects which are bound to
     names in the module’s dictionary.  The "init" function of
     extension modules is not called a second time.

   * As with all other objects in Python the old objects are only
     reclaimed after their reference counts drop to zero.

   * The names in the module namespace are updated to point to any
     new or changed objects.

   * Other references to the old objects (such as names external to
     the module) are not rebound to refer to the new objects and must
     be updated in each namespace where they occur if that is desired.

   There are a number of other caveats:

   When a module is reloaded, its dictionary (containing the module’s
   global variables) is retained.  Redefinitions of names will
   override the old definitions, so this is generally not a problem.
   If the new version of a module does not define a name that was
   defined by the old version, the old definition remains.  This
   feature can be used to the module’s advantage if it maintains a
   global table or cache of objects — with a "try" statement it can
   test for the table’s presence and skip its initialization if
   desired:

      try:
          cache
      except NameError:
          cache = {}

   It is generally not very useful to reload built-in or dynamically
   loaded modules.  Reloading "sys", "__main__", "builtins" and other
   key modules is not recommended.  In many cases extension modules
   are not designed to be initialized more than once, and may fail in
   arbitrary ways when reloaded.

   If a module imports objects from another module using "from" …
   "import" …, calling "reload()" for the other module does not
   redefine the objects imported from it — one way around this is to
   re-execute the "from" statement, another is to use "import" and
   qualified names (*module*.*name*) instead.

   If a module instantiates instances of a class, reloading the module
   that defines the class does not affect the method definitions of
   the instances — they continue to use the old class definition.  The
   same is true for derived classes.

repr(object)

   Return a string containing a printable representation of an object.
   This is the same value yielded by conversions (reverse quotes).  It
   is sometimes useful to be able to access this operation as an
   ordinary function.  For many types, this function makes an attempt
   to return a string that would yield an object with the same value
   when passed to "eval()", otherwise the representation is a string
   enclosed in angle brackets that contains the name of the type of
   the object together with additional information often including the
   name and address of the object.  A class can control what this
   function returns for its instances by defining a "__repr__()"
   method.

reversed(seq)

   Donne un *iterator* inversé. *seq* doit être un objet ayant une
   méthode "__reverse__()" ou supportant le protocole séquence (la
   méthode "__len__()" et la méthode "__getitem__()" avec des
   arguments entiers commençant à zéro).

   Nouveau dans la version 2.4.

   Modifié dans la version 2.6: Added the possibility to write a
   custom "__reversed__()" method.

round(number[, ndigits])

   Return the floating point value *number* rounded to *ndigits*
   digits after the decimal point.  If *ndigits* is omitted, it
   defaults to zero. The result is a floating point number.  Values
   are rounded to the closest multiple of 10 to the power minus
   *ndigits*; if two multiples are equally close, rounding is done
   away from 0 (so, for example, "round(0.5)" is "1.0" and
   "round(-0.5)" is "-1.0").

   Note: Le comportement de "round()" avec les nombres à virgule
     flottante peut être surprenant : par exemple "round(2.675, 2)"
     donne "2.67" au lieu de "2.68". Ce n’est pas un bug, mais dû au
     fait que la plupart des fractions de décimaux ne peuvent pas être
     représentés exactement en nombre a virgule flottante. Voir
     Arithmétique en Nombre à Virgule Flottante : Problèmes et Limites
     pour plus d’information.

class set([iterable])

   Donne un nouveau "set", dont les éléments peuvent être extraits
   d”*iterable*. "set" est une classe native. Voir "set" et Types
   d’ensembles — set, frozenset pour la documentation de cette classe.

   D’autres conteneurs existent, typiquement : "frozenset", "list",
   "tuple", et "dict", ainsi que le module "collections".

   Nouveau dans la version 2.4.

setattr(object, name, value)

   C’est le complément de "getattr()". Les arguments sont : un objet,
   une chaîne, et une valeur de type arbitraire. La chaîne peut nommer
   un attribut existant ou un nouvel attribut. La fonction assigne la
   valeur à l’attribut, si l’objet l’autorise. Par exemple,
   "setattr(x, 'foobar', 123)" équivaut à "x.foobar = 123".

class slice(stop)
class slice(start, stop[, step])

   Donne un objet "slice" représentant un ensemble d’indices spécifiés
   par "range(start, stop, step)". Les arguments *start* et *step*
   valent "None" par défaut. Les objets *slice* (tranches) ont les
   attributs suivants en lecture seule : "start", "stop", et "step"
   qui valent simplement les trois arguments (ou leurs valeur par
   défaut). Ils n’ont pas d’autres fonctionnalité explicite, cependant
   ils sont utilisés par *Numerical Python* et d’autres bibliothèques
   tierces. Les objets *slice* sont aussi générés par la syntaxe
   d’indiçage étendue. Par exemple "a[start:stop:step]" ou
   "a[start:stop, i]". Voir "itertools.islice()" pour une version
   alternative donnant un itérateur.

sorted(iterable[, cmp[, key[, reverse]]])

   Donne une nouvelle liste triée depuis les éléments d”*iterable*.

   The optional arguments *cmp*, *key*, and *reverse* have the same
   meaning as those for the "list.sort()" method (described in section
   Types de séquences mutables).

   *cmp* specifies a custom comparison function of two arguments
   (iterable elements) which should return a negative, zero or
   positive number depending on whether the first argument is
   considered smaller than, equal to, or larger than the second
   argument: "cmp=lambda x,y: cmp(x.lower(), y.lower())".  The default
   value is "None".

   *key* spécifie une fonction d’un argument utilisé pour extraire une
   clef de comparaison de chaque élément de la liste :
   "key=str.lower". La valeur par défaut est "None" (compare les
   éléments directement).

   *reverse*, une valeur booléenne. Si elle est "True", la liste
   d’éléments est triée comme si toutes les comparaisons étaient
   inversées.

   In general, the *key* and *reverse* conversion processes are much
   faster than specifying an equivalent *cmp* function.  This is
   because *cmp* is called multiple times for each list element while
   *key* and *reverse* touch each element only once.  Use
   "functools.cmp_to_key()" to convert an old-style *cmp* function to
   a *key* function.

   La fonction native "sorted()" est garantie stable. Un tri est
   stable s’il garantie de ne pas changer l’ordre relatif des éléments
   égaux entre eux. C’est util pour trier en plusieurs passes, par
   exemple par département puis par salaire).

   Pour des exemple de tris et un bref tutoriel, consultez Sorting HOW
   TO.

   Nouveau dans la version 2.4.

staticmethod(function)

   Donne une méthode statique pour *function*.

   Une méthode statique ne reçoit pas de premier argument
   implicitement. Voilà comment déclarer une méthode statique :

      class C(object):
          @staticmethod
          def f(arg1, arg2, ...):
              ...

   La forme "@staticmethod" est un *decorator* de fonction. Voir la
   description des définitions de fonction dans Function definitions
   pour plus de détails.

   Elle peut être appelée soit sur une classe (tel que "C.f()") ou sur
   une instance (tel que "C().f()"). L’instance est ignorée, sauf pour
   sa classe.

   Les méthodes statiques en Python sont similaires à celles trouvées
   en Java ou en C++. Consultez "classmethod()" pour une variante
   utile pour créer des constructeurs alternatifs.

   Pour plus d’informations sur les méthodes statiques, consultez la
   documentation de la hiérarchie des types standards dans The
   standard type hierarchy.

   Nouveau dans la version 2.2.

   Modifié dans la version 2.4: Function decorator syntax added.

class str(object= »)

   Return a string containing a nicely printable representation of an
   object.  For strings, this returns the string itself.  The
   difference with "repr(object)" is that "str(object)" does not
   always attempt to return a string that is acceptable to "eval()";
   its goal is to return a printable string.  If no argument is given,
   returns the empty string, "''".

   For more information on strings see Sequence Types — str, unicode,
   list, tuple, bytearray, buffer, xrange which describes sequence
   functionality (strings are sequences), and also the string-specific
   methods described in the Méthodes de chaînes de caractères section.
   To output formatted strings use template strings or the "%"
   operator described in the String Formatting Operations section. In
   addition see the String Services section. See also "unicode()".

sum(iterable[, start])

   Additionne *start* et les éléments d”*iterable* de gauche à droite
   et en donne le total. *start* vaut "0" par défaut. Les éléments
   d”*iterable* sont normalement des nombres, et la valeur de *start*
   ne peut pas être une chaîne.

   Pour certains cas, il existe de bonnes alternatives à "sum()". La
   bonne méthode, et rapide, de concaténer une séquence de chaînes est
   d’appeler "''.join(séquence)". Pour additionner des nombres à
   virgule flottante avec une meilleure précision, voir "math.fsum()".
   Pour concaténer une série d’itérables, utilisez plutôt
   "itertools.chain()".

   Nouveau dans la version 2.3.

super(type[, object-or-type])

   Donne un objet mandataire (*proxy object*) déléguant les appels de
   méthode à une classe parente ou soeur de type *type*. C’est utile
   pour accéder à des méthodes héritées et substituées dans la classe.
   L’ordre de recherche est le même que celui utilisé par "getattr()"
   sauf que *type* lui même est sauté.

   L’attribut "__mro__" de *type* liste l’ordre de recherche de la
   méthode de résolution utilisée par "getattr()" et "super()".
   L’attribut est dynamique et peut changer lorsque la hiérarchie
   d’héritage est modifiée.

   Si le second argument est omis, l’objet *super* obtenu n’est pas
   lié. Si le second argument est un objet, "isinstance(obj, type)"
   doit être vrai. Si le second argument est un type,
   "issubclass(type2, type)" doit être vrai (c’est utile pour les
   méthodes de classe).

   Note: "super()" only works for *new-style class*es.

   Il existe deux autres cas d’usage typiques pour *super*. Dans une
   hiérarchie de classes à héritage simple, *super* peut être utilisé
   pour obtenir la classe parente sans avoir à la nommer
   explicitement, rendant le code plus maintenable. Cet usage se
   rapproche de l’usage de *super* dans d’autres langages de
   programmation.

   Le second est la gestion d’héritage multiple coopératif dans un
   environnement d’exécution dynamique. Cet usage est unique à Python,
   il ne se retrouve ni dans les langages compilés statiquement, ni
   dans les langages ne gérant que l’héritage simple. Cela rend
   possible d’implémenter un héritage en diamant dans lequel plusieurs
   classes parentes implémentent la même méthode. Une bonne conception
   implique que chaque méthode doit avoir la même signature lors de
   leur appels dans tous les cas (parce que l’ordre des appels est
   déterminée à l’exécution, parce que l’ordre s’adapte aux
   changements dans la hiérarchie, et parce que l’ordre peut inclure
   des classes soeur inconnues avant l’exécution).

   Dans tous les cas, un appel typique à une classe parente ressemble
   à :

      class C(B):
          def method(self, arg):
              super(C, self).method(arg)

   Notez que "super()" fait partie de l’implémentation du processus de
   liaison de recherche d’attributs pointés explicitement tel que
   "super().__getitem__(name)". Il le fait en implémentant sa propre
   méthode "__getattribute__()" pour rechercher les classes dans un
   ordre prévisible supportant l’héritage multiple coopératif. En
   conséquence, "super()" n’est pas défini pour les recherches
   implicites via des instructions ou des opérateurs tel que
   "super()[name]".

   Also note that "super()" is not limited to use inside methods.  The
   two argument form specifies the arguments exactly and makes the
   appropriate references.

   Pour des suggestions pratiques sur la conception de classes
   coopératives utilisant "super()", consultez guide to using super().

   Nouveau dans la version 2.2.

tuple([iterable])

   Return a tuple whose items are the same and in the same order as
   *iterable*’s items.  *iterable* may be a sequence, a container that
   supports iteration, or an iterator object. If *iterable* is already
   a tuple, it is returned unchanged. For instance, "tuple('abc')"
   returns "('a', 'b', 'c')" and "tuple([1, 2, 3])" returns "(1, 2,
   3)".  If no argument is given, returns a new empty tuple, "()".

   "tuple" is an immutable sequence type, as documented in Sequence
   Types — str, unicode, list, tuple, bytearray, buffer, xrange. For
   other containers see the built in "dict", "list", and "set"
   classes, and the "collections" module.

class type(object)
class type(name, bases, dict)

   With one argument, return the type of an *object*.  The return
   value is a type object.  The "isinstance()" built-in function is
   recommended for testing the type of an object.

   With three arguments, return a new type object.  This is
   essentially a dynamic form of the "class" statement. The *name*
   string is the class name and becomes the "__name__" attribute; the
   *bases* tuple itemizes the base classes and becomes the "__bases__"
   attribute; and the *dict* dictionary is the namespace containing
   definitions for class body and becomes the "__dict__"  attribute.
   For example, the following two statements create identical "type"
   objects:

   >>> class X(object):
   ...     a = 1
   ...
   >>> X = type('X', (object,), dict(a=1))

   Nouveau dans la version 2.2.

unichr(i)

   Return the Unicode string of one character whose Unicode code is
   the integer *i*.  For example, "unichr(97)" returns the string
   "u'a'".  This is the inverse of "ord()" for Unicode strings.  The
   valid range for the argument depends how Python was configured – it
   may be either UCS2 [0..0xFFFF] or UCS4 [0..0x10FFFF]. "ValueError"
   is raised otherwise. For ASCII and 8-bit strings see "chr()".

   Nouveau dans la version 2.0.

unicode(object= »)
unicode(object[, encoding[, errors]])

   Return the Unicode string version of *object* using one of the
   following modes:

   If *encoding* and/or *errors* are given, "unicode()" will decode
   the object which can either be an 8-bit string or a character
   buffer using the codec for *encoding*. The *encoding* parameter is
   a string giving the name of an encoding; if the encoding is not
   known, "LookupError" is raised. Error handling is done according to
   *errors*; this specifies the treatment of characters which are
   invalid in the input encoding.  If *errors* is "'strict'" (the
   default), a "ValueError" is raised on errors, while a value of
   "'ignore'" causes errors to be silently ignored, and a value of
   "'replace'" causes the official Unicode replacement character,
   "U+FFFD", to be used to replace input characters which cannot be
   decoded.  See also the "codecs" module.

   If no optional parameters are given, "unicode()" will mimic the
   behaviour of "str()" except that it returns Unicode strings instead
   of 8-bit strings. More precisely, if *object* is a Unicode string
   or subclass it will return that Unicode string without any
   additional decoding applied.

   For objects which provide a "__unicode__()" method, it will call
   this method without arguments to create a Unicode string. For all
   other objects, the 8-bit string version or representation is
   requested and then converted to a Unicode string using the codec
   for the default encoding in "'strict'" mode.

   For more information on Unicode strings see Sequence Types — str,
   unicode, list, tuple, bytearray, buffer, xrange which describes
   sequence functionality (Unicode strings are sequences), and also
   the string-specific methods described in the Méthodes de chaînes de
   caractères section. To output formatted strings use template
   strings or the "%" operator described in the String Formatting
   Operations section. In addition see the String Services section.
   See also "str()".

   Nouveau dans la version 2.0.

   Modifié dans la version 2.2: Support for "__unicode__()" added.

vars([object])

   Renvoie l’attribut "__dict__" d’un module, d’une classe, d’une
   instance ou de n’importe quel objet avec un attribut "__dict__".

   Objects such as modules and instances have an updateable "__dict__"
   attribute; however, other objects may have write restrictions on
   their "__dict__" attributes (for example, new-style classes use a
   dictproxy to prevent direct dictionary updates).

   Sans augment, "vars()" se comporte comme "locals()". Notez que le
   dictionnaire des variables locales n’est utile qu’en lecture, car
   ses écritures sont ignorées.

xrange(stop)
xrange(start, stop[, step])

   This function is very similar to "range()", but returns an xrange
   object instead of a list.  This is an opaque sequence type which
   yields the same values as the corresponding list, without actually
   storing them all simultaneously. The advantage of "xrange()" over
   "range()" is minimal (since "xrange()" still has to create the
   values when asked for them) except when a very large range is used
   on a memory-starved machine or when all of the range’s elements are
   never used (such as when the loop is usually terminated with
   "break").  For more information on xrange objects, see XRange Type
   and Sequence Types — str, unicode, list, tuple, bytearray, buffer,
   xrange.

   **CPython implementation detail:** "xrange()" is intended to be
   simple and fast.  Implementations may impose restrictions to
   achieve this.  The C implementation of Python restricts all
   arguments to native C longs (« short » Python integers), and also
   requires that the number of elements fit in a native C long.  If a
   larger range is needed, an alternate version can be crafted using
   the "itertools" module: "islice(count(start, step), (stop-
   start+step-1+2*(step<0))//step)".

zip([iterable, …])

   This function returns a list of tuples, where the *i*-th tuple
   contains the *i*-th element from each of the argument sequences or
   iterables. The returned list is truncated in length to the length
   of the shortest argument sequence. When there are multiple
   arguments which are all of the same length, "zip()" is similar to
   "map()" with an initial argument of "None". With a single sequence
   argument, it returns a list of 1-tuples. With no arguments, it
   returns an empty list.

   The left-to-right evaluation order of the iterables is guaranteed.
   This makes possible an idiom for clustering a data series into
   n-length groups using "zip(*[iter(s)]*n)".

   "zip()" peut être utilisée conjointement avec l’opérateur "*" pour
   de-*zip*-per une liste :

      >>> x = [1, 2, 3]
      >>> y = [4, 5, 6]
      >>> zipped = zip(x, y)
      >>> zipped
      [(1, 4), (2, 5), (3, 6)]
      >>> x2, y2 = zip(*zipped)
      >>> x == list(x2) and y == list(y2)
      True

   Nouveau dans la version 2.0.

   Modifié dans la version 2.4: Formerly, "zip()" required at least
   one argument and "zip()" raised a "TypeError" instead of returning
   an empty list.

__import__(name[, globals[, locals[, fromlist[, level]]]])

   Note: C’est une fonction avancée qui n’est pas fréquemment
     nécessaire, contrairement à "importlib.import_module()".

   This function is invoked by the "import" statement.  It can be
   replaced (by importing the "__builtin__" module and assigning to
   "__builtin__.__import__") in order to change semantics of the
   "import" statement, but nowadays it is usually simpler to use
   import hooks (see **PEP 302**).  Direct use of "__import__()" is
   rare, except in cases where you want to import a module whose name
   is only known at runtime.

   La fonction importe le module *name*, utilisant potentiellement
   *globals* et *locals* pour déterminer comment interpréter le nom
   dans le contexte d’un paquet. *fromlist* donne le nom des objets ou
   sous-modules qui devraient être importés du module *name*.
   L’implémentation standard n’utilise pas l’argument *locals* et
   n’utilise *globals* que pour déterminer le contexte du paquet de
   l’instruction "import".

   *level* specifies whether to use absolute or relative imports.  The
   default is "-1" which indicates both absolute and relative imports
   will be attempted.  "0" means only perform absolute imports.
   Positive values for *level* indicate the number of parent
   directories to search relative to the directory of the module
   calling "__import__()".

   Lorsque la variable *name* est de la forme "package.module",
   normalement, le paquet le plus haut (le nom jusqu’au premier point)
   est donné, et *pas* le module nommé par *name*. Cependant,
   lorsqu’un argument *fromlist* est fourni, le module nommé par
   *name* est donné.

   Par exemple, l’instruction "import spam" donne un bytecode
   ressemblant ai code suivant :

      spam = __import__('spam', globals(), locals(), [], -1)

   L’instruction "import ham.ham" appelle :

      spam = __import__('spam.ham', globals(), locals(), [], -1)

   Notez comment "__import__()" donne le module le plus haut ici parce
   que c’est l’objet lié à un nom par l’nstruction "import".

   En revanche, l’instruction "from spam.ham import eggs, saucage as
   saus" donne :

      _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
      eggs = _temp.eggs
      saus = _temp.sausage

   Ici le module "spam.ham" est donné par "__import__()". De cet
   objet, les noms à importer sont récupérés et assignés à leurs noms
   respectifs.

   Si vous voulez simplement importer un module (potentiellement dans
   un paquet) par son nom, utilisez "importlib.import_module()".

   Modifié dans la version 2.5: The level parameter was added.

   Modifié dans la version 2.5: Keyword support for parameters was
   added.


Non-essential Built-in Functions
********************************

There are several built-in functions that are no longer essential to
learn, know or use in modern Python programming.  They have been kept
here to maintain backwards compatibility with programs written for
older versions of Python.

Python programmers, trainers, students and book writers should feel
free to bypass these functions without concerns about missing
something important.

apply(function, args[, keywords])

   The *function* argument must be a callable object (a user-defined
   or built-in function or method, or a class object) and the *args*
   argument must be a sequence.  The *function* is called with *args*
   as the argument list; the number of arguments is the length of the
   tuple. If the optional *keywords* argument is present, it must be a
   dictionary whose keys are strings.  It specifies keyword arguments
   to be added to the end of the argument list. Calling "apply()" is
   different from just calling "function(args)", since in that case
   there is always exactly one argument.  The use of "apply()" is
   equivalent to "function(*args, **keywords)".

   Obsolète depuis la version 2.3: Use "function(*args, **keywords)"
   instead of "apply(function, args, keywords)" (see Séparation des
   listes d’arguments).

buffer(object[, offset[, size]])

   The *object* argument must be an object that supports the buffer
   call interface (such as strings, arrays, and buffers).  A new
   buffer object will be created which references the *object*
   argument. The buffer object will be a slice from the beginning of
   *object* (or from the specified *offset*). The slice will extend to
   the end of *object* (or will have a length given by the *size*
   argument).

coerce(x, y)

   Return a tuple consisting of the two numeric arguments converted to
   a common type, using the same rules as used by arithmetic
   operations. If coercion is not possible, raise "TypeError".

intern(string)

   Enter *string* in the table of « interned » strings and return the
   interned string – which is *string* itself or a copy. Interning
   strings is useful to gain a little performance on dictionary lookup
   – if the keys in a dictionary are interned, and the lookup key is
   interned, the key comparisons (after hashing) can be done by a
   pointer compare instead of a string compare.  Normally, the names
   used in Python programs are automatically interned, and the
   dictionaries used to hold module, class or instance attributes have
   interned keys.

   Modifié dans la version 2.3: Interned strings are not immortal
   (like they used to be in Python 2.2 and before); you must keep a
   reference to the return value of "intern()" around to benefit from
   it.

-[ Notes ]-

[1] It is used relatively rarely so does not warrant being made
    into a statement.

[2] Specifying a buffer size currently has no effect on systems
    that don’t have "setvbuf()".  The interface to specify the buffer
    size is not done using a method that calls "setvbuf()", because
    that may dump core when called after any I/O has been performed,
    and there’s no reliable way to determine whether this is the case.

[3] In the current implementation, local variable bindings cannot
    normally be affected this way, but variables retrieved from other
    scopes (such as modules) can be.  This may change.

"os" — Diverses interfaces pour le système d’exploitation
*********************************************************

Ce module fournit une manière portable d’utiliser les fonctionnalités
dépendantes du système d’exploitation. Si vous voulez uniquement lire
ou écrire dans un fichier, voir "open()", si vous voulez manipuler des
chemins, voir le module "os.path", et si vous voulez lire toutes les
lignes de tous les fichiers listés par l’invite de commande, voir le
module "fileinput". Pour créer des fichiers temporaires, voir le
module "tempfile", et pour une manipulation haut niveau des fichiers
et dossiers, voir le module "shutil".

Notes sur la disponibilité de ces fonctions :

* La conception des modules natifs Python dépendants du système
  d’exploitation est qu’une même fonctionnalité utilise une même
  interface. Par exemple, la fonction "os.stat(path)" renvoie des
  informations sur les statistiques de *path* dans le même format (qui
  est originaire de l’interface POSIX).

* Les extensions propres à un certain système d’exploitation sont
  également disponible par le module "os", mais les utiliser est bien
  entendu une menace pour la portabilité.

* Une note « Disponibilité : Unix  » signifie que cette fonction est
  communément implémentée dans les systèmes Unix. Une telle note ne
  prétend pas l’existence de la fonction sur un système d’exploitation
  particulier.

* Si ce n’est pas mentionné séparément, toutes les fonctions se
  réclamant « Disponibilité : Unix » sont supportées sur Mac OS X, qui
  est basé sur Unix.

Note: Toutes les fonctions de ce module lèvent une "OSError" dans le
  cas d’un chemin ou nom de fichier invalide ou inaccessible, ou si
  d’autres arguments sont de type correct mais non supporté par le
  système d’exploitation.

exception os.error

   Un alias pour les exceptions natives "OSError".

os.name

   The name of the operating system dependent module imported.  The
   following names have currently been registered: "'posix'", "'nt'",
   "'os2'", "'ce'", "'java'", "'riscos'".

   Voir aussi: "sys.platform" a une granularité plus fine.
     "os.uname()" donne des informations de version dépendantes de
     système.

     Le module "platform" fournit des vérifications détaillées pour
     l’identité du système.


Paramètres de proccessus
========================

Ces fonctions et valeurs fournissent des informations et agissent sur
le processus actuel et sur l’utilisateur.

os.environ

   Un objet *mapping* représentant la variable d’environnement. Par
   exemple "environ['HOME']" est le chemin vers votre répertoire
   personnel (sur certaines plate-formes), et est équivalent à
   "getenv("HOME")" en C.

   Ce *mapping* est capturé la première fois que le module "os" est
   importé, typiquement pendant le démarrage de Python, lors de
   l’exécution de "site.py". Les changements de l’environnement opérés
   après cette capture ne sont pas répercutés dans "os.environ", à
   part les modifications directes de "os.environ".

   Si la plate-forme supporte la fonction "putenv()", ce *mapping*
   peut être utilisé pour modifier l’environnement autant que pour
   l’interroger. "putenv()" sera appelée automatiquement quand le
   *mapping* sera modifié.

   Note: Appeler "putenv()" ne change pas directement "os.environ",
     donc il est préférable de modifier "os.environ".

   Note: Sur certaines plate-formes, dont FreeBSD et Mac OS X,
     procéder à des assignations sur "environ" peut causer des fuites
     de mémoire. Referez-vous à la documentation système de
     "putenv()".

   Si "putenv()" n’est pas fourni, une copie modifiée de ce
   dictionnaire peut être passé aux fonctions appropriées de création
   de processus pour forcer l’utilisation d’un environnement modifié
   pour le processus fils.

   Si la plate-forme supporte la fonction "unsetenv()", vous pouvez
   supprimer des éléments de ce dictionnaire pour supprimer des
   variables d’environnement. La fonction "unsetenv()" sera appelée
   automatiquement quand un élément est supprimé de "os.environ", ou
   quand l’une des méthodes "pop()" ou "clear()" est appelée.

   Modifié dans la version 2.6: Also unset environment variables when
   calling "os.environ.clear()" and "os.environ.pop()".

os.chdir(path)
os.fchdir(fd)
os.getcwd()

   Ces fonctions sont décrites dans Fichiers et Répertoires.

os.ctermid()

   Renvoie l’identifiant de fichier correspondant au terminal
   contrôlant le processus.

   Disponibilité : Unix.

os.getegid()

   Renvoie l’id du groupe effectif du processus actuel. Ça correspond
   au bit « *set id* » du fichier qui s’exécute dans le processus
   actuel.

   Disponibilité : Unix.

os.geteuid()

   Renvoie l’id de l’utilisateur effectif du processus actuel.

   Disponibilité : Unix.

os.getgid()

   Renvoie l’id de groupe réel du processus actuel.

   Disponibilité : Unix.

os.getgroups()

   Renvoie une liste d’ids de groupes additionnels associés au
   processus actuel.

   Disponibilité : Unix.

   Note: Sur Mac OS X, le comportement de "getgroups()" diffère
     légèrement des autres plate-formes Unix. Si l’interpréteur Python
     était compilé avec une cible de déploiement de "10.5" ou moins,
     "getgroups()" renverrait la liste des ids de groupes effectifs
     associés au processus courant de l’utilisateur ; le nombre
     d’éléments de cette liste est limité par le système, typiquement
     16, et peut être modifié par des appels à "setgroups()" si les
     privilèges ont été convenablement assignés. Si compilé avec une
     cible de déploiement supérieure à "10.5", la fonction
     "getgroups()" renvoie la liste des accès du groupe actuel pour
     l’utilisateur associé à l’id utilisateur du processus ; la liste
     d’accès du groupe peut changer durant la vie du processus, elle
     n’est pas affectée par les appels à "setgroups()" et sa longueur
     n’est pas limitée à 16.  La valeur de la cible de déploiement,
     "MACOSX_DEPLOYMENT_TARGET", peut être obtenue par la fonction
     "sysconfig.get_config_var()".

os.initgroups(username, gid)

   Appelle la fonction système initgroups() pour initialiser la liste
   des groupes d’accès des groupes dont *username* est membre, plus le
   groupe spécifié par *gid*.

   Disponibilité : Unix.

   Nouveau dans la version 2.7.

os.getlogin()

   Return the name of the user logged in on the controlling terminal
   of the process.  For most purposes, it is more useful to use the
   environment variable "LOGNAME" to find out who the user is, or
   "pwd.getpwuid(os.getuid())[0]" to get the login name of the
   process’s real user id.

   Disponibilité : Unix.

os.getpgid(pid)

   Renvoie l’id de groupe de processus du processus dont l’id est
   *pid*. Si *pid* vaut 0, l’id de groupe de processus du processus
   actuel est renvoyé.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.getpgrp()

   Renvoie l’id du groupe de processus actuel.

   Disponibilité : Unix.

os.getpid()

   Renvoie l’id du processus actuel.

   Disponibilité : Unix, Windows.

os.getppid()

   Return the parent’s process id.

   Disponibilité : Unix.

os.getresuid()

   Renvoie un *tuple* (ruid, euid, suid) dénotant les ids de
   l’utilisateur réel, effectif et sauvé du processus actuel.

   Disponibilité : Unix.

   Nouveau dans la version 2.7.

os.getresgid()

   Renvoie un *tuple* (rgid, egid, sgid) dénotant les ids des groupes
   de processus réel effectif, et sauvé du processus actuel.

   Disponibilité : Unix.

   Nouveau dans la version 2.7.

os.getuid()

   Renvoie l’id réel du processus actuel.

   Disponibilité : Unix.

os.getenv(varname[, value])

   Return the value of the environment variable *varname* if it
   exists, or *value* if it doesn’t.  *value* defaults to "None".

   Disponibilité : la plupart des dérivés Unix, Windows.

os.putenv(varname, value)

   Set the environment variable named *varname* to the string *value*.
   Such changes to the environment affect subprocesses started with
   "os.system()", "popen()" or "fork()" and "execv()".

   Disponibilité : la plupart des dérivés Unix, Windows.

   Note: Sur certaines plate-formes, incluant FreeBSD et Mac OS X,
     assigner "environ" peut causer des fuites de mémoire. Referez-
     vous à à la documentation système de putenv.

   Quand "putenv()" est supporté, les assignations d’éléments dans
   "os.environ" sont automatiquement traduites en appels
   correspondants à "putenv()". Cependant, des appels à "putenv()" ne
   mettent pas "os.environ" à jour. Il est donc préférable d’assigner
   les éléments de "os.environ".

os.setegid(egid)

   Définit l’id du groupe de processus effectif du processus actuel.

   Disponibilité : Unix.

os.seteuid(euid)

   Définit l’id de l’utilisateur effectif du processus actuel.

   Disponibilité : Unix.

os.setgid(gid)

   Définit l’id du groupe de processus actuel.

   Disponibilité : Unix.

os.setgroups(groups)

   Place *groups* dans la liste d’ids de groupes additionnels
   associée. *groups* doit être une séquence, et chaque élément doit
   être yb ebtuer udentifiant un groupe. Cette opération est
   typiquement disponible uniquement pour le superutilisateur.

   Disponibilité : Unix.

   Nouveau dans la version 2.2.

   Note: Sur Mac OS X, la longueur de *groups* ne peut pas dépasser
     le nombre maximum d’ids effectifs de groupes défini par le
     système, typiquement 16. Voir la documentation de "getgroups()"
     pour les cas où getgroups() ne renvoierait pas la même liste de
     groupes que celle définie par l’appel à setgroups().

os.setpgrp()

   Produit l’appel système "setpgrp()" ou "setpgrp(0, 0)" selon la
   version implémentée (s’il y en a une). Voir le manuel Unix pour la
   sémantique de l’opération.

   Disponibilité : Unix.

os.setpgid(pid, pgrp)

   Produit l’appel système "setpgid()" pour placer l’id du groupe de
   processus contenant le processus d’id *pid* dans le groupe de
   processus d’id *pgrp*. Voir le manuel Unix pour la sémantique.

   Disponibilité : Unix.

os.setregid(rgid, egid)

   Définit l’id des groupes réel et effectif du processus actuel.

   Disponibilité : Unix.

os.setresgid(rgid, egid, sgid)

   Définit l’id des groupes réel, effectif et sauvé du processus
   actuel.

   Disponibilité : Unix.

   Nouveau dans la version 2.7.

os.setresuid(ruid, euid, suid)

   Définit l’id des utilisateurs réel, effectif et sauvé du processus
   actuel.

   Disponibilité : Unix.

   Nouveau dans la version 2.7.

os.setreuid(ruid, euid)

   Définit l’id des utilisateurs réel et effectif du processus actuel.

   Disponibilité : Unix.

os.getsid(pid)

   Produit l’appel système "getsid()". Voir le manuel Unix pour la
   sémantique.

   Disponibilité : Unix.

   Nouveau dans la version 2.4.

os.setsid()

   Produit l’appel système "setsid()". Voir le manuel Unix pour la
   sémantique.

   Disponibilité : Unix.

os.setuid(uid)

   Définit l’id de l’utilisateur du processus actuel.

   Disponibilité : Unix.

os.strerror(code)

   Renvoie le message d’erreur correspondant au code d’erreur *code*.
   Sur les plate-formes où "strerror()" renvoie "NULL" quand un numéro
   d’erreur inconnu est donné, une "ValueError" est levée.

   Disponibilité : Unix, Windows.

os.umask(mask)

   Définit le *umask* actuel et renvoie la valeur précédente.

   Disponibilité : Unix, Windows.

os.uname()

   Return a 5-tuple containing information identifying the current
   operating system.  The tuple contains 5 strings: "(sysname,
   nodename, release, version, machine)".  Some systems truncate the
   nodename to 8 characters or to the leading component; a better way
   to get the hostname is "socket.gethostname()"  or even
   "socket.gethostbyaddr(socket.gethostname())".

   Disponibilité : dérivés récents de Unix.

os.unsetenv(varname)

   Unset (delete) the environment variable named *varname*. Such
   changes to the environment affect subprocesses started with
   "os.system()", "popen()" or "fork()" and "execv()".

   Quand "unsetenv()" est supportée, la suppression d’éléments dans
   "os.environ" est automatiquement interprétée en un appel
   correspondant à "unsetenv()", mais les appels à "unsetenv()" ne
   mettent pas "os.environ" à jour. Donc il est préférable de
   supprimer les éléments de "os.environ".

   Disponibilité : la plupart des dérivés Unix, Windows.


Création de Fichiers Objets
===========================

These functions create new file objects. (See also "open()".)

os.fdopen(fd[, mode[, bufsize]])

   Return an open file object connected to the file descriptor *fd*.
   The *mode* and *bufsize* arguments have the same meaning as the
   corresponding arguments to the built-in "open()" function.  If
   "fdopen()" raises an exception, it leaves *fd* untouched
   (unclosed).

   Disponibilité : Unix, Windows.

   Modifié dans la version 2.3: When specified, the *mode* argument
   must now start with one of the letters "'r'", "'w'", or "'a'",
   otherwise a "ValueError" is raised.

   Modifié dans la version 2.5: On Unix, when the *mode* argument
   starts with "'a'", the *O_APPEND* flag is set on the file
   descriptor (which the "fdopen()" implementation already does on
   most platforms).

os.popen(command[, mode[, bufsize]])

   Open a pipe to or from *command*.  The return value is an open file
   object connected to the pipe, which can be read or written
   depending on whether *mode* is "'r'" (default) or "'w'". The
   *bufsize* argument has the same meaning as the corresponding
   argument to the built-in "open()" function.  The exit status of the
   command (encoded in the format specified for "wait()") is available
   as the return value of the "close()" method of the file object,
   except that when the exit status is zero (termination without
   errors), "None" is returned.

   Disponibilité : Unix, Windows.

   Obsolète depuis la version 2.6: This function is obsolete.  Use the
   "subprocess" module.  Check especially the Replacing Older
   Functions with the subprocess Module section.

   Modifié dans la version 2.0: This function worked unreliably under
   Windows in earlier versions of Python. This was due to the use of
   the "_popen()" function from the libraries provided with Windows.
   Newer versions of Python do not use the broken implementation from
   the Windows libraries.

os.tmpfile()

   Return a new file object opened in update mode ("w+b").  The file
   has no directory entries associated with it and will be
   automatically deleted once there are no file descriptors for the
   file.

   Disponibilité : Unix, Windows.

There are a number of different "popen*()" functions that provide
slightly different ways to create subprocesses.

Obsolète depuis la version 2.6: All of the "popen*()" functions are
obsolete. Use the "subprocess" module.

For each of the "popen*()" variants, if *bufsize* is specified, it
specifies the buffer size for the I/O pipes. *mode*, if provided,
should be the string "'b'" or "'t'"; on Windows this is needed to
determine whether the file objects should be opened in binary or text
mode.  The default value for *mode* is "'t'".

Also, for each of these variants, on Unix, *cmd* may be a sequence, in
which case arguments will be passed directly to the program without
shell intervention (as with "os.spawnv()"). If *cmd* is a string it
will be passed to the shell (as with "os.system()").

These methods do not make it possible to retrieve the exit status from
the child processes.  The only way to control the input and output
streams and also retrieve the return codes is to use the "subprocess"
module; these are only available on Unix.

For a discussion of possible deadlock conditions related to the use of
these functions, see Flow Control Issues.

os.popen2(cmd[, mode[, bufsize]])

   Execute *cmd* as a sub-process and return the file objects
   "(child_stdin, child_stdout)".

   Obsolète depuis la version 2.6: This function is obsolete.  Use the
   "subprocess" module.  Check especially the Replacing Older
   Functions with the subprocess Module section.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 2.0.

os.popen3(cmd[, mode[, bufsize]])

   Execute *cmd* as a sub-process and return the file objects
   "(child_stdin, child_stdout, child_stderr)".

   Obsolète depuis la version 2.6: This function is obsolete.  Use the
   "subprocess" module.  Check especially the Replacing Older
   Functions with the subprocess Module section.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 2.0.

os.popen4(cmd[, mode[, bufsize]])

   Execute *cmd* as a sub-process and return the file objects
   "(child_stdin, child_stdout_and_stderr)".

   Obsolète depuis la version 2.6: This function is obsolete.  Use the
   "subprocess" module.  Check especially the Replacing Older
   Functions with the subprocess Module section.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 2.0.

(Note that "child_stdin, child_stdout, and child_stderr" are named
from the point of view of the child process, so *child_stdin* is the
child’s standard input.)

This functionality is also available in the "popen2" module using
functions of the same names, but the return values of those functions
have a different order.


Opérations sur les Descripteurs de Fichiers
===========================================

Ces fonctions opèrent sur des flux d’E/S référencés par des
descripteurs de fichiers.

Les descripteurs de fichiers sont de petits entiers correspondant à un
fichier qui a été ouvert par le processus courant. Par exemple,
l’entrée standard est habituellement le descripteur de fichier 0, la
sortie standard est 1, et le flux standard d’erreur est 2. Les autres
fichiers ouverts par un processus vont se voir assigner 3, 4, 5, etc.
Le nom « descripteur de fichier » est légèrement trompeur : sur les
plate-formes Unix, les *sockets* et les *pipes* sont également
référencés par des descripteurs.

The "fileno()" method can be used to obtain the file descriptor
associated with a file object when required.  Note that using the file
descriptor directly will bypass the file object methods, ignoring
aspects such as internal buffering of data.

os.close(fd)

   Ferme le descripteur de fichier *fd*.

   Disponibilité : Unix, Windows.

   Note: Cette fonction est destinée aux opérations d’E/S de bas
     niveau et doit être appliquée à un descripteur de fichier comme
     ceux donnés par "os.open()" ou "pipe()". Pour fermer un « fichier
     objet » renvoyé par la primitive "open()", "popen()" ou
     "fdopen()", il faut utiliser sa méthode "close()".

os.closerange(fd_low, fd_high)

   Close all file descriptors from *fd_low* (inclusive) to *fd_high*
   (exclusive), ignoring errors. Equivalent to:

      for fd in xrange(fd_low, fd_high):
          try:
              os.close(fd)
          except OSError:
              pass

   Disponibilité : Unix, Windows.

   Nouveau dans la version 2.6.

os.dup(fd)

   Return a duplicate of file descriptor *fd*.

   Disponibilité : Unix, Windows.

os.dup2(fd, fd2)

   Duplicate file descriptor *fd* to *fd2*, closing the latter first
   if necessary.

   Disponibilité : Unix, Windows.

os.fchmod(fd, mode)

   Change the mode of the file given by *fd* to the numeric *mode*.
   See the docs for "chmod()" for possible values of *mode*.

   Disponibilité : Unix.

   Nouveau dans la version 2.6.

os.fchown(fd, uid, gid)

   Change the owner and group id of the file given by *fd* to the
   numeric *uid* and *gid*.  To leave one of the ids unchanged, set it
   to -1.

   Disponibilité : Unix.

   Nouveau dans la version 2.6.

os.fdatasync(fd)

   Force l’écriture du fichier ayant le descripteur *fd* sur le
   disque. Ne force pas la mise à jour des méta-données.

   Disponibilité : Unix.

   Note: Cette fonction n’est pas disponible sur MacOS.

os.fpathconf(fd, name)

   Renvoie les informations de la configuration du système pour un
   fichier ouvert. *name* spécifie la valeur de la configuration à
   récupérer, ça peut être une chaîne de caractères avec le nom d’une
   valeur système définie ; ces valeurs sont spécifiées dans certains
   standards (POSIX.1, Unix 95, Unix 98, et d’autres). Certaines
   plate-formes définissent des noms additionnels également. Les noms
   connus par le système d’exploitation sont donnés dans le
   dictionnaire "pathconf_names". Pour les variables de configuration
   qui ne sont pas inclues dans ce *mapping*, passer un entier pour
   *name* est également accepté.

   Si *name* est une chaîne de caractères et n’est pas connu, une
   "ValueError" est levée. Si une valeur spécifique de *name* n’est
   pas supportée par le système hôte, même si elle est incluse dans
   "pathconf_names", une "OSError" est levée avec "errno.EINVAL" pour
   code d’erreur.

   Disponibilité : Unix.

os.fstat(fd)

   Return status for file descriptor *fd*, like "stat()".

   Disponibilité : Unix, Windows.

os.fstatvfs(fd)

   Return information about the filesystem containing the file
   associated with file descriptor *fd*, like "statvfs()".

   Disponibilité : Unix.

os.fsync(fd)

   Force l’écriture du fichier ayant le descripteur *fd* sur le
   disque. Sur Unix, cet appel appel la fonction native "fsync()", sur
   Windows, la fonction MS "_commit()".

   If you’re starting with a Python file object *f*, first do
   "f.flush()", and then do "os.fsync(f.fileno())", to ensure that all
   internal buffers associated with *f* are written to disk.

   Availability: Unix, and Windows starting in 2.2.3.

os.ftruncate(fd, length)

   Truncate the file corresponding to file descriptor *fd*, so that it
   is at most *length* bytes in size.

   Disponibilité : Unix.

os.isatty(fd)

   Renvoie "True" si le descripteur de fichier *fd* est ouvert et
   connecté à un périphérique tty(-compatible), sinon "False".

os.lseek(fd, pos, how)

   Place la position actuelle du descripteur de fichier *fd* à la
   position *pos*, modifié par *how* : "SEEK_SET" ou "0" pour placer
   la position à partir du début du fichier, "SEEK_CUR" ou "1" pour la
   placer à partir de la position actuelle, et "SEEK_END" ou "2" pour
   la placer par rapport à la fin du fichier. Renvoie la nouvelle
   position du curseur en bytes, à partir du début.

   Disponibilité : Unix, Windows.

os.SEEK_SET
os.SEEK_CUR
os.SEEK_END

   Paramètres de la fonction "lseek()". Leur valeur est respectivement
   0, 1, et 2.

   Availability: Windows, Unix.

   Nouveau dans la version 2.5.

os.open(file, flags[, mode])

   Open the file *file* and set various flags according to *flags* and
   possibly its mode according to *mode*. The default *mode* is "0777"
   (octal), and the current umask value is first masked out.  Return
   the file descriptor for the newly opened file.

   For a description of the flag and mode values, see the C run-time
   documentation; flag constants (like "O_RDONLY" and "O_WRONLY") are
   defined in this module too (see open() flag constants).  In
   particular, on Windows adding "O_BINARY" is needed to open files in
   binary mode.

   Disponibilité : Unix, Windows.

   Note: This function is intended for low-level I/O.  For normal
     usage, use the built-in function "open()", which returns a « file
     object » with "read()" and "write()" methods (and many more).  To
     wrap a file descriptor in a « file object », use "fdopen()".

os.openpty()

   Open a new pseudo-terminal pair. Return a pair of file descriptors
   "(master, slave)" for the pty and the tty, respectively. For a
   (slightly) more portable approach, use the "pty" module.

   Disponibilité : certains dérivés Unix.

os.pipe()

   Create a pipe.  Return a pair of file descriptors "(r, w)" usable
   for reading and writing, respectively.

   Disponibilité : Unix, Windows.

os.read(fd, n)

   Read at most *n* bytes from file descriptor *fd*. Return a string
   containing the bytes read.  If the end of the file referred to by
   *fd* has been reached, an empty string is returned.

   Disponibilité : Unix, Windows.

   Note: Cette fonction est destinée aux E/S bas niveau et doit être
     appliquée à un descripteur de fichier comme renvoyé par
     "os.open()" ou "pipe()". Pour lire dans un « fichier objet »
     renvoyé par la primitive "open()", "popen()" ou "fdopen()", ou
     par "stdin", utilisez sa méthode "read()" ou "readline()".

os.tcgetpgrp(fd)

   Renvoie le groupe de processus associé au terminal donné par *fd*
   (un descripteur de fichier ouvert comme renvoyé par "os.open()").

   Disponibilité : Unix.

os.tcsetpgrp(fd, pg)

   Place *pg* dans le groupe de processus associé au terminal donné
   par *fd* (un descripteur de fichier ouvert comme renvoyé par
   "os.open()").

   Disponibilité : Unix.

os.ttyname(fd)

   Renvoie une chaîne de caractères spécifiant le périphérique
   terminal associé au descripteur de fichier *fd*. Si *fd* n’est pas
   associé à un périphérique terminal, une exception est levée.

   Disponibilité : Unix.

os.write(fd, str)

   Write the string *str* to file descriptor *fd*. Return the number
   of bytes actually written.

   Disponibilité : Unix, Windows.

   Note: cette fonction est destinée aux E/S bas niveau et doit être
     appliquée à un descripteur de fichier comme renvoyé par
     "os.open()" ou "pipe()". Pour écrire dans un « fichier objet »
     renvoyé par la primitive "open()", "popen()", ou par "fdopen()",
     ou par "sys.stdout" ou "sys.stderr", utilisez sa méthode
     "write()".


"open()" flag constants
-----------------------

The following constants are options for the *flags* parameter to the
"open()" function.  They can be combined using the bitwise OR operator
"|".  Some of them are not available on all platforms.  For
descriptions of their availability and use, consult the *open(2)*
manual page on Unix or the MSDN on Windows.

os.O_RDONLY
os.O_WRONLY
os.O_RDWR
os.O_APPEND
os.O_CREAT
os.O_EXCL
os.O_TRUNC

   Les constantes ci-dessus sont disponibles sur Unix et Windows.

os.O_DSYNC
os.O_RSYNC
os.O_SYNC
os.O_NDELAY
os.O_NONBLOCK
os.O_NOCTTY

   Les constantes ci-dessus sont uniquement disponibles sur Unix.

os.O_BINARY
os.O_NOINHERIT
os.O_SHORT_LIVED
os.O_TEMPORARY
os.O_RANDOM
os.O_SEQUENTIAL
os.O_TEXT

   Les constantes ci-dessus sont uniquement disponibles sur Windows.

os.O_ASYNC
os.O_DIRECT
os.O_DIRECTORY
os.O_NOFOLLOW
os.O_NOATIME
os.O_SHLOCK
os.O_EXLOCK

   Les constantes ci-dessus sont des extensions et ne sont pas
   présentes si elles ne sont pas définies par la bibliothèque C.


Fichiers et Répertoires
=======================

os.access(path, mode)

   Utilise l’uid/gid réel pour tester l’accès à *path*. Notez que la
   plupart des opérations utiliseront l’uid/gid effectif, dès lors
   cette méthode peut être utilisée dans un environnement suid/sgid
   pour tester si l’utilisateur invoquant a les droits d’accès pour
   accéder à *path*. *mode* devrait être "F_OK" pour tester
   l’existence de *path*, ou il peut être le OR (OU inclusif) d’une ou
   plusieurs des constantes suivantes : "R_OK", "W_OK", et "X_OK" pour
   tester les permissions. Renvoie "True" si l’accès est permis, et
   "False" s’il ne l’est pas. Voir la page de manuel Unix *access(2)*
   pour plus d’informations.

   Disponibilité : Unix, Windows.

   Note: Utiliser "access()" pour vérifier si un utilisateur est
     autorisé (par exemple) à ouvrir un fichier avant d’effectivement
     le faire en utilisant "open()" crée une faille de sécurité :
     l’utilisateur peut exploiter le court intervalle de temps entre
     la vérification et l’ouverture du fichier pour le manipuler. Il
     est préférable d’utiliser les techniques *EAFP*. Par exemple :

        if os.access("myfile", os.R_OK):
            with open("myfile") as fp:
                return fp.read()
        return "some default data"

     est mieux écrit comme suit :

        try:
            fp = open("myfile")
        except IOError as e:
            if e.errno == errno.EACCES:
                return "some default data"
            # Not a permission error.
            raise
        else:
            with fp:
                return fp.read()

   Note: Les opérations d’E/S peuvent échouer même quand "access()"
     indique qu’elles devraient réussir, particulièrement pour les
     opérations sur les systèmes de fichiers réseaux qui peuvent avoir
     une sémantique de permissions au-delà du modèle de bits de
     permission usuel POSIX.

os.F_OK

   Value to pass as the *mode* parameter of "access()" to test the
   existence of *path*.

os.R_OK

   Value to include in the *mode* parameter of "access()" to test the
   readability of *path*.

os.W_OK

   Value to include in the *mode* parameter of "access()" to test the
   writability of *path*.

os.X_OK

   Value to include in the *mode* parameter of "access()" to determine
   if *path* can be executed.

os.chdir(path)

   Change le répertoire de travail actuel par *path*.

   Disponibilité : Unix, Windows.

os.fchdir(fd)

   Change the current working directory to the directory represented
   by the file descriptor *fd*.  The descriptor must refer to an
   opened directory, not an open file.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.getcwd()

   Renvoie une chaîne de caractères représentant le répertoire de
   travail actuel.

   Disponibilité : Unix, Windows.

os.getcwdu()

   Return a Unicode object representing the current working directory.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 2.3.

os.chflags(path, flags)

   Définit les marqueurs de *path* par la valeur numérique *flags*.
   *flags* peut prendre une combinaison (OU bit-à-bit) des valeurs
   suivantes (comme défini dans le module "stat") :

   * "stat.UF_NODUMP"

   * "stat.UF_IMMUTABLE"

   * "stat.UF_APPEND"

   * "stat.UF_OPAQUE"

   * "stat.UF_NOUNLINK"

   * "stat.UF_COMPRESSED"

   * "stat.UF_HIDDEN"

   * "stat.SF_ARCHIVED"

   * "stat.SF_IMMUTABLE"

   * "stat.SF_APPEND"

   * "stat.SF_NOUNLINK"

   * "stat.SF_SNAPSHOT"

   Disponibilité : Unix.

   Nouveau dans la version 2.6.

os.chroot(path)

   Change the root directory of the current process to *path*.
   Availability: Unix.

   Nouveau dans la version 2.2.

os.chmod(path, mode)

   Change le mode de *path* par la valeur numérique *mode*. *mode*
   peut prendre une des valeurs suivantes (comme défini dans le module
   "stat") ou une combinaison (OU bit-à-bit) de ces valeurs :

   * "stat.S_ISUID"

   * "stat.S_ISGID"

   * "stat.S_ENFMT"

   * "stat.S_ISVTX"

   * "stat.S_IREAD"

   * "stat.S_IWRITE"

   * "stat.S_IEXEC"

   * "stat.S_IRWXU"

   * "stat.S_IRUSR"

   * "stat.S_IWUSR"

   * "stat.S_IXUSR"

   * "stat.S_IRWXG"

   * "stat.S_IRGRP"

   * "stat.S_IWGRP"

   * "stat.S_IXGRP"

   * "stat.S_IRWXO"

   * "stat.S_IROTH"

   * "stat.S_IWOTH"

   * "stat.S_IXOTH"

   Disponibilité : Unix, Windows.

   Note: Although Windows supports "chmod()", you can only  set the
     file’s read-only flag with it (via the "stat.S_IWRITE"  and
     "stat.S_IREAD" constants or a corresponding integer value).  All
     other bits are ignored.

os.chown(path, uid, gid)

   Change the owner and group id of *path* to the numeric *uid* and
   *gid*. To leave one of the ids unchanged, set it to -1.

   Disponibilité : Unix.

os.lchflags(path, flags)

   Set the flags of *path* to the numeric *flags*, like "chflags()",
   but do not follow symbolic links.

   Disponibilité : Unix.

   Nouveau dans la version 2.6.

os.lchmod(path, mode)

   Change the mode of *path* to the numeric *mode*. If path is a
   symlink, this affects the symlink rather than the target. See the
   docs for "chmod()" for possible values of *mode*.

   Disponibilité : Unix.

   Nouveau dans la version 2.6.

os.lchown(path, uid, gid)

   Change the owner and group id of *path* to the numeric *uid* and
   *gid*. This function will not follow symbolic links.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.link(source, link_name)

   Create a hard link pointing to *source* named *link_name*.

   Disponibilité : Unix.

os.listdir(path)

   Return a list containing the names of the entries in the directory
   given by *path*.  The list is in arbitrary order.  It does not
   include the special entries "'.'" and "'..'" even if they are
   present in the directory.

   Disponibilité : Unix, Windows.

   Modifié dans la version 2.3: On Windows NT/2k/XP and Unix, if
   *path* is a Unicode object, the result will be a list of Unicode
   objects. Undecodable filenames will still be returned as string
   objects.

os.lstat(path)

   Perform the equivalent of an "lstat()" system call on the given
   path. Similar to "stat()", but does not follow symbolic links.  On
   platforms that do not support symbolic links, this is an alias for
   "stat()".

os.mkfifo(path[, mode])

   Create a FIFO (a named pipe) named *path* with numeric mode *mode*.
   The default *mode* is "0666" (octal).  The current umask value is
   first masked out from the mode.

   Disponibilité : Unix.

   Les FIFOs sont des tubes qui peuvent être accédés comme des
   fichiers normaux. Les FIFOs existent jusqu’à ce qu’ils soient
   retirés (par exemple, à l’aide de "os.unlink()"). Généralement, les
   FIFOs sont utilisé comme communication entre des processus de type
   « client » et « serveur » : le serveur ouvre le FIFO pour le lire,
   et le client l’ouvre pour écrire dedans. Notez que "mkfifo()"
   n’ouvre pas le FIFO — il crée juste un point de rendez-vous.

os.mknod(filename[, mode=0600[, device=0]])

   Create a filesystem node (file, device special file or named pipe)
   named *filename*. *mode* specifies both the permissions to use and
   the type of node to be created, being combined (bitwise OR) with
   one of "stat.S_IFREG", "stat.S_IFCHR", "stat.S_IFBLK", and
   "stat.S_IFIFO" (those constants are available in "stat"). For
   "stat.S_IFCHR" and "stat.S_IFBLK", *device* defines the newly
   created device special file (probably using "os.makedev()"),
   otherwise it is ignored.

   Nouveau dans la version 2.3.

os.major(device)

   Extrait le nombre majeur de périphérique d’un nombre de
   périphérique brut (habituellement le champ "st_dev" ou "st_rdev" de
   "stat").

   Nouveau dans la version 2.3.

os.minor(device)

   Extrait le nombre mineur de périphérique d’un nombre de
   périphérique brut (habituellement le champ "st_dev" ou "st_rdev" de
   "stat").

   Nouveau dans la version 2.3.

os.makedev(major, minor)

   Compose un nombre de périphérique brut à partir des nombres de
   périphérique mineur et majeur.

   Nouveau dans la version 2.3.

os.mkdir(path[, mode])

   Create a directory named *path* with numeric mode *mode*. The
   default *mode* is "0777" (octal).  If the directory already exists,
   "OSError" is raised.

   Sous certains systèmes, *mode* est ignoré.  Quand il est utilisé,
   il lui est premièrement appliqué le masque courant *umask*.  Si des
   bits autres que les 9 derniers sont activés (i.e. les 3 derniers
   chiffres de la représentation octale de *mode*), leur signification
   sera dépendante de la plate-forme.  Sous certaines plate-formes,
   ils seront ignorés et vous devrez appeler explicitement "chmod()"
   pour les modifier.

   Il est également possible  de créer des répertoires temporaires,
   voir la fonction "tempfile.mkdtemp()" du module "tempfile".

   Disponibilité : Unix, Windows.

os.makedirs(path[, mode])

   Recursive directory creation function.  Like "mkdir()", but makes
   all intermediate-level directories needed to contain the leaf
   directory.  Raises an "error" exception if the leaf directory
   already exists or cannot be created.  The default *mode* is "0777"
   (octal).

   Le paramètre *mode* est passé à "mkdir()" ; voir la description de
   mkdir() pour comprendre comment cela est interprété.

   Note: "makedirs()" will become confused if the path elements to
     create include "os.pardir".

   Nouveau dans la version 1.5.2.

   Modifié dans la version 2.3: This function now handles UNC paths
   correctly.

os.pathconf(path, name)

   Renvoie des informations sur la configurations relatives à un
   fichier déterminé. *name* spécifie la valeur de configuration à
   récupérer ; ce peut être une chaîne de caractères qui est le nom
   d’une valeur système particulière. Ces noms sont spécifiés dans
   certains standards (POSIX.1, Unix 95, Unix 98, etc). Certaines
   plate-formes définissent des noms supplémentaires également. Les
   noms connus du système d’exploitation hôte sont donnés dans le
   dictionnaire "pathconf_names". Pour les variables de configuration
   non incluses dans ce *mapping*, passer un entier pour *name* est
   également accepté.

   Si *name* est une chaîne de caractères et n’est pas connu, une
   "ValueError" est levée. Si une valeur spécifique de *name* n’est
   pas supportée par le système hôte, même si elle est incluse dans
   "pathconf_names", une "OSError" est levée avec "errno.EINVAL" pour
   code d’erreur.

   Disponibilité : Unix.

os.pathconf_names

   Dictionary mapping names accepted by "pathconf()" and "fpathconf()"
   to the integer values defined for those names by the host operating
   system.  This can be used to determine the set of names known to
   the system. Availability: Unix.

os.readlink(path)

   Renvoie une chaîne de caractères représentant le chemin vers lequel
   le lien symbolique pointe. Le résultat peut être soit un chemin
   relatif, soit un chemin absolu. S’il est relatif, il peut être
   converti en chemin absolu en utilisant
   "os.path.join(os.path.dirname(path), result)".

   Modifié dans la version 2.6: If the *path* is a Unicode object the
   result will also be a Unicode object.

   Disponibilité : Unix.

os.remove(path)

   Remove (delete) the file *path*.  If *path* is a directory,
   "OSError" is raised; see "rmdir()" below to remove a directory.
   This is identical to the "unlink()" function documented below.  On
   Windows, attempting to remove a file that is in use causes an
   exception to be raised; on Unix, the directory entry is removed but
   the storage allocated to the file is not made available until the
   original file is no longer in use.

   Disponibilité : Unix, Windows.

os.removedirs(path)

   Supprime des répertoires récursivement. Focntionne comme "rmdir()"
   si ce n’est que si le répertoire feuille est retiré avec succès,
   "removedirs()" essaye de supprimer successivement chaque répertoire
   parent mentionné dans *path* jusqu’à ce qu’un erreur ne soit levée
   (ce qui est ignoré car la signification générale en est qu’un
   répertoire parent n’est pas vide). Par exemple,
   "os.removedirs('foo/bar/baz')" supprimera d’abord le répertoire
   "'foo/bar/baz'", et ensuite supprimera "'foo/bar'" et puis "'foo'"
   s’ils sont vides. Lève une "OSError" si le répertoire feuille n’a
   pas pu être supprimé avec succès.

   Nouveau dans la version 1.5.2.

os.rename(src, dst)

   Rename the file or directory *src* to *dst*.  If *dst* is a
   directory, "OSError" will be raised.  On Unix, if *dst* exists and
   is a file, it will be replaced silently if the user has permission.
   The operation may fail on some Unix flavors if *src* and *dst* are
   on different filesystems.  If successful, the renaming will be an
   atomic operation (this is a POSIX requirement).  On Windows, if
   *dst* already exists, "OSError" will be raised even if it is a
   file; there may be no way to implement an atomic rename when *dst*
   names an existing file.

   Disponibilité : Unix, Windows.

os.renames(old, new)

   Focntion récursive de renommage de fichiers ou répertoires.
   Fonctionne comme "rename()", si ce n’est que la création d’un
   répertoire intermédiaire nécessaire pour rendre le nouveau chemin
   correct est essayé en premier. Après le renommage, les répertoires
   correspondant aux segments de chemin les plus à droite de l’ancien
   nom seront élagués en utilisant "removedirs()".

   Nouveau dans la version 1.5.2.

   Note: Cette fonction peut échouer avec la nouvelle structure de
     dictionnaire définie si vous n’avez pas les permissions
     nécessaires pour supprimer le répertoire ou fichier feuille.

os.rmdir(path)

   Supprime (retire) le répertoire *path*. Ne fonctionne que lorsque
   le répertoire est vide, sinon une "OSError" est levée. Afin de
   supprimer toute la hiérarchie de dossier, la fonction
   "shutil.rmtree()" peut être utilisée.

   Disponibilité : Unix, Windows.

os.stat(path)

   Perform the equivalent of a "stat()" system call on the given path.
   (This function follows symlinks; to stat a symlink use "lstat()".)

   The return value is an object whose attributes correspond to the
   members of the "stat" structure, namely:

   * "st_mode" - protection bits,

   * "st_ino" - inode number,

   * "st_dev" - device,

   * "st_nlink" - number of hard links,

   * "st_uid" - user id of owner,

   * "st_gid" - group id of owner,

   * "st_size" - size of file, in bytes,

   * "st_atime" - time of most recent access,

   * "st_mtime" - time of most recent content modification,

   * "st_ctime" - platform dependent; time of most recent metadata
     change on Unix, or the time of creation on Windows)

   Modifié dans la version 2.3: If "stat_float_times()" returns
   "True", the time values are floats, measuring seconds. Fractions of
   a second may be reported if the system supports that. See
   "stat_float_times()" for further discussion.

   Sur certains systèmes Unix (tels que Linux), les attributs suivants
   peuvent également être disponibles :

   * "st_blocks" - number of 512-byte blocks allocated for file

   * "st_blksize" - filesystem blocksize for efficient file system
     I/O

   * "st_rdev" - type of device if an inode device

   * "st_flags" - user defined flags for file

   Sur d’autres systèmes Unix (tels que FreeBSD), les attributs
   suivants peuvent être disponibles (mais peuvent être complétés
   uniquement lorsque le super-utilisateur *root* tente de les
   utiliser).

   * "st_gen" - file generation number

   * "st_birthtime" - time of file creation

   On RISCOS systems, the following attributes are also available:

   * "st_ftype" (file type)

   * "st_attrs" (attributes)

   * "st_obtype" (object type).

   Note: La signification et la précision exacte des attributs
     "st_atime", "st_mtime", et "st_ctime" dépendent du système
     d’exploitation et du système de fichier. Par exemple sur les
     systèmes Windows qui utilisent un système de fichier FAT ou
     FAT32, "st_mtime" a une précision de 2 secondes, et "st_atime" a
     une précision de 1 jour. Regardez la documentation de votre
     système d’exploitation pour plus de détails.

   For backward compatibility, the return value of "stat()" is also
   accessible as a tuple of at least 10 integers giving the most
   important (and portable) members of the "stat" structure, in the
   order "st_mode", "st_ino", "st_dev", "st_nlink", "st_uid",
   "st_gid", "st_size", "st_atime", "st_mtime", "st_ctime". More items
   may be added at the end by some implementations.

   Le module standard "stat" définit des fonctions et des constantes
   qui sont utiles pour l’extraction d’informations d’une structure
   "stat". (Sur Windows, certains éléments sont remplis avec des
   valeurs factices.)

   Exemples :

      >>> import os
      >>> statinfo = os.stat('somefile.txt')
      >>> statinfo
      (33188, 422511, 769, 1, 1032, 100, 926, 1105022698,1105022732, 1105022732)
      >>> statinfo.st_size
      926

   Disponibilité : Unix, Windows.

   Modifié dans la version 2.2: Added access to values as attributes
   of the returned object.

   Modifié dans la version 2.5: Added "st_gen" and "st_birthtime".

os.stat_float_times([newvalue])

   Détermine si "stat_result" représente les horodatages par des
   objets à virgule flottante. Si *newvalue* vaut "True", les appels à
   "stat()" qui suivront renvoieront des flottants. Si *newvalue* vaut
   "False", les appels qui suivront renverront des entiers. Si
   *newvalue* est omise, la valeur actuelle est renvoyée.

   Pour des raisons de compatibilité avec les anciennes versions de
   Python, accéder un objet de type "stat_result" renvoie toujours des
   entiers.

   Modifié dans la version 2.5: Python renvoie des valeurs flottantes
   par défaut maintenant. Les applications qui ne fonctionnent pas
   correctement avec des horodatages flottants peuvent utiliser cette
   fonction pour restaurer l’ancien comportement.

   La précision des horodatages (qui est la plus petite fraction
   possible) dépend du système. Certains systèmes supportent
   uniquement une précision à la seconde ; sur ces systèmes, la
   fraction sera toujours zéro.

   Il est recommandé que cette option ne soit changée qu’au lancement
   du programme dans le module *__main__*. Les bibliothèques ne
   devraient jamais changer cette option. Si une application utilise
   une bibliothèque qui fonctionne mal avec les horodatages en nombres
   flottants, cette application devrait temporairement retirer cette
   possibilité jusqu’à ce que la bibliothèque ait été corrigée.

os.statvfs(path)

   Exécute un appel système "statvfs()" sur le chemin donné par
   *path*. La valeur de retour est un objet dont les attributs
   décrivent le système de fichier sur le chemin donné, et
   correspondent auxmembres de la structure "statvfs" nommés :
   "f_bsize", "f_frsize", "f_blocks", "f_bfree", "f_bavail",
   "f_files", "f_ffree", "f_favail", "f_flag", "f_namemax".

   For backward compatibility, the return value is also accessible as
   a tuple whose values correspond to the attributes, in the order
   given above. The standard module "statvfs" defines constants that
   are useful for extracting information from a "statvfs" structure
   when accessing it as a sequence; this remains useful when writing
   code that needs to work with versions of Python that don’t support
   accessing the fields as attributes.

   Disponibilité : Unix.

   Modifié dans la version 2.2: Added access to values as attributes
   of the returned object.

os.symlink(source, link_name)

   Create a symbolic link pointing to *source* named *link_name*.

   Disponibilité : Unix.

os.tempnam([dir[, prefix]])

   Return a unique path name that is reasonable for creating a
   temporary file. This will be an absolute path that names a
   potential directory entry in the directory *dir* or a common
   location for temporary files if *dir* is omitted or "None".  If
   given and not "None", *prefix* is used to provide a short prefix to
   the filename.  Applications are responsible for properly creating
   and managing files created using paths returned by "tempnam()"; no
   automatic cleanup is provided. On Unix, the environment variable
   "TMPDIR" overrides *dir*, while on Windows "TMP" is used.  The
   specific behavior of this function depends on the C library
   implementation; some aspects are underspecified in system
   documentation.

   Avertissement: Use of "tempnam()" is vulnerable to symlink
     attacks; consider using "tmpfile()" (section Création de Fichiers
     Objets) instead.

   Disponibilité : Unix, Windows.

os.tmpnam()

   Return a unique path name that is reasonable for creating a
   temporary file. This will be an absolute path that names a
   potential directory entry in a common location for temporary files.
   Applications are responsible for properly creating and managing
   files created using paths returned by "tmpnam()"; no automatic
   cleanup is provided.

   Avertissement: Use of "tmpnam()" is vulnerable to symlink
     attacks; consider using "tmpfile()" (section Création de Fichiers
     Objets) instead.

   Availability: Unix, Windows.  This function probably shouldn’t be
   used on Windows, though: Microsoft’s implementation of "tmpnam()"
   always creates a name in the root directory of the current drive,
   and that’s generally a poor location for a temp file (depending on
   privileges, you may not even be able to open a file using this
   name).

os.TMP_MAX

   The maximum number of unique names that "tmpnam()" will generate
   before reusing names.

os.unlink(path)

   Remove (delete) the file *path*.  This is the same function as
   "remove()"; the "unlink()" name is its traditional Unix name.

   Disponibilité : Unix, Windows.

os.utime(path, times)

   Set the access and modified times of the file specified by *path*.
   If *times* is "None", then the file’s access and modified times are
   set to the current time. (The effect is similar to running the Unix
   program **touch** on the path.)  Otherwise, *times* must be a
   2-tuple of numbers, of the form "(atime, mtime)" which is used to
   set the access and modified times, respectively. Whether a
   directory can be given for *path* depends on whether the operating
   system implements directories as files (for example, Windows does
   not).  Note that the exact times you set here may not be returned
   by a subsequent "stat()" call, depending on the resolution with
   which your operating system records access and modification times;
   see "stat()".

   Modifié dans la version 2.0: Added support for "None" for *times*.

   Disponibilité : Unix, Windows.

os.walk(top, topdown=True, onerror=None, followlinks=False)

   Génère les noms de fichier dans un arbre de répertoire en
   parcourant l’arbre soit de bas-en-haut, soit de haut-en-bas. Pour
   chaque répertoire dans l’arbre enraciné en le répertoire *rop*
   (incluant ledit répertoire *top*), fournit un 3-uple "(dirpath,
   dirnames, filenames)".

   *dirpath* est une chaîne de caractères contenant le chemin vers le
   répertoire. *dirnames* est une liste de noms de sous-répertoires
   dans *dirpath* (en excluant "'.'" et "'..'"). *filenames* est une
   liste de fichiers (non-répertoires) dans *dirpath*. Notez que les
   noms dans la liste ne contiennent aucune composante de chemin. Pour
   récupérer le chemin complet (qui commence à *top*) vers un
   répertoire dans *dirpath*, faites "os.path.join(dirpath, name)".

   Si l’argument optionnel *topdown* vaut "True" ou n’est pas
   spécifié, le triplet pour un répertoire est généré avant les
   triplets de tous ses sous-répertoires (les répertoires sotn générés
   de haut-en-bas). Si *topdown* vaut "False", le triplet pour un
   répertoire est généré après les triplets de tous ses sous-
   répertoires (les répertoires sont générés de bas-en-haut). Peu
   importe la valeur de *topdown*, la liste des sous-répertoires est
   récupérée avant que les tuples pour le répertoires et ses sous-
   répertoires ne soient générés.

   Quand *topdown* vaut "True", l’appelant peut modifier la liste
   *dirnames* en place (par exemple en utilisant "del" ou
   l’assignation par *slicing* (par tranches)) et "walk()" ne fera sa
   récursion que dans les sous-répertoires dont le nom reste dans
   *dirnames* ; cela peut être utilisé pour élaguer la recherche,
   imposer un ordre particulier de visite, ou encore pour informer
   "walk()" des répertoires créés par l’appelant ou renommés avant
   qu’il quitte "walk()" à nouveau. Modifier *dirnames* quand*topdown*
   vaut "False" n’a aucun effet dur le comportement du parcours parce
   qu’en mode bas-en-haut, les répertoires dans *dirnames* sont
   générés avant que *dirpath* ne soit lui-même généré.

   Par défaut, les erreurs d’un appel à "listdir()" sont ignorées. Si
   l’argument optionnel *onerror* est spécifié, il devrait être une
   fonction, il sera appelé avec un argument, une instance de
   "OSError". Il peut reporter l’erreur ou continuer le parcours, ou
   lever l’exception pour avorter le parcours. Notez que le nom de
   fichier est disponible par “attribut "filename" de l’objet
   exception.

   Par défaut, la fonction "walk()" ne parcourra pas les liens
   symboliques qui mènent à un répertoire. Définissez *followlinks*
   avec« True«  pour visiter les répertoires pointés par des liens
   symboliques sur les systèmes qui le supporte.

   Nouveau dans la version 2.6: The *followlinks* parameter.

   Note: Soyez au courant que définir *followlinks* avec "True" peut
     mener à une récursion infinie si un lien pointe vers un
     répertoire parent de lui-même. "walk()" ne garde pas de trace des
     répertoires qu’il a déjà visité.

   Note: Si vous passez un chemin relatif, ne changer pas le
     répertoire de travail actuel entre deux exécutions de "walk()".
     "walk()" ne change jamais le répertoire actuel, et suppose que
     l’appelant ne le fait pas non plus.

   Cet exemple affiche le nombre de bytes pris par des fichiers non-
   répertoires dans chaque répertoire à partir du répertoire de
   départ, si ce n’est qu’il ne cherche pas après un sous-répertoire
   CSV :

      import os
      from os.path import join, getsize
      for root, dirs, files in os.walk('python/Lib/email'):
          print root, "consumes",
          print sum(getsize(join(root, name)) for name in files),
          print "bytes in", len(files), "non-directory files"
          if 'CVS' in dirs:
              dirs.remove('CVS')  # don't visit CVS directories

   Dans le prochain exemple, parcourir l’arbre de bas-en-haut est
   essentiel : "rmdir()" ne permet pas de supprimer un répertoire
   avant qu’il ne soit vide :

      # Delete everything reachable from the directory named in "top",
      # assuming there are no symbolic links.
      # CAUTION:  This is dangerous!  For example, if top == '/', it
      # could delete all your disk files.
      import os
      for root, dirs, files in os.walk(top, topdown=False):
          for name in files:
              os.remove(os.path.join(root, name))
          for name in dirs:
              os.rmdir(os.path.join(root, name))

   Nouveau dans la version 2.3.


Gestion des processus
=====================

Ces fonctions peuvent être utilisées pour créer et gérer des
processus.

Les variantes des fonctions "exec*" prennent une liste d’arguments
pour le nouveau programme chargé dans le processus. Dans tous les cas,
le premier de ces arguments est passé au nouveau programme comme son
propre nomplutôt que comme un argument qu’un utilisateur peut avoir
tapé en ligne de commande. Pour les programmeurs C, c’est l’argument
"argv[0]" qui est passé à la fonction "main()" du programme. Par
exemple, "os.execv('/bin/echo/', ['foo', 'bar'])" affichera uniquement
"bar" sur la sortie standard ; "foo" semblera être ignoré.

os.abort()

   Génère un signal "SIGABRT" au processus actuel. Sur Linux, le
   comportement par défaut est de produire un vidage système (*Core
   Dump*) ; sur Windows, le processus renvoie immédiatement un code
   d’erreur "3". Attention : aappeler cette fonction n’appellera pas
   le gestionnaire de signal Python enregistré par "SIGABRT" à l’aide
   de "signal.signal()".

   Disponibilité : Unix, Windows.

os.execl(path, arg0, arg1, …)
os.execle(path, arg0, arg1, …, env)
os.execlp(file, arg0, arg1, …)
os.execlpe(file, arg0, arg1, …, env)
os.execv(path, args)
os.execve(path, args, env)
os.execvp(file, args)
os.execvpe(file, args, env)

   Ces fonctions exécutent toutes un nouveau programme, remplaçant le
   processus actuel, elles ne renvoient pas. Sur Unix, le nouvel
   exécutable est chargé dans le processus actuel, et aura le même
   identifiant de processus (PID) que l’appelant. Les erreurs seront
   reportées par des exceptions "OSError".

   Le processus actuel est remplacé immédiatement. Les fichiers objets
   et descripteurs de fichiers ne sont pas purgés, donc s’il est
   possible que des données aient été mises en tampon pour ces
   fichiers, vous devriez les purger manuellement en utilisant
   "sys.stdout.flush()" ou "os.fsync()" avant d’appeler une fonction
   "exec*".

   Les variantes « l » et « v » des fonctions "exec*" différent sur la
   manière de passer les arguments de ligne de commande. Les variantes
   « l » sont probablement les plus simples à utiliser si le nombre de
   paramètres est fixé lors de l’écriture du code. Les paramètres
   individuels deviennent alors des paramètres additionnels aux
   fonctions "exec*()". Les variantes « v » sont préférables quand le
   nombre de paramètres est variable et qu’ils sont passés dans une
   liste ou un *tuple* dans le paramètre *args*. Dans tous les cas,
   les arguments aux processus fils devraient commencer avec le nom de
   la commande à lancer, mais ce n’est pas obligatoire.

   Les variantes qui incluent un « p »vers la fin ("execlp()",
   "execlpe()", "execvp()", et "execvpe()") utiliseront la variable
   d’environnement "PATH" pour localiser le programme *file*. Quand
   l’environnement est remplacé (en utilisant une des variantes
   "exec*e", discutées dans le paragraphe suivant), le nouvel
   environnement est utilisé comme source de la variable
   d’environnement "PATH". Les autres variantes "execl()", "execle()",
   "execv()", et "execve()" n’utiliseront pas la variable
   d’environnement "PATH" pour localiser l’exécutable. *path* doit
   contenir un chemin absolue ou relatif approprié.

   Pour les fonctions "execle()", "execlpe()", "execve()", and
   "execvpe()" (notez qu’elle finissent toutes par « e »), le
   paramètre *env* doit être un *mapping* qui est utilisé pour définir
   les variables d’environnement du nouveau processus (celles-ci sont
   utilisées à la place de l’environnement du nouveau processus). Les
   fonctions "execl()", "execlp()", "execv()", et "execvp()" causent
   toutes un héritage de l’environnement du processus actuel par le
   processus fils.

   Disponibilité : Unix, Windows.

os._exit(n)

   Quitte le processus avec le statut *n*, sans appeler les
   gestionnaires de nettoyage, sans purger les tampons des fichiers,
   etc.

   Disponibilité : Unix, Windows.

   Note: La méthode standard pour quitter est "sys.exit(n)".
     "_exit()" devrait normalement être utilisé uniquement par le
     processus fils après un "fork()".

Les codes de sortie suivants sont définis et peuvent être utilisés
avec "_exit()", mais ils ne sont pas nécessaires. Ils sont typiquement
utilisés pour les programmes systèmes écrits en Python, comme un
programme de gestion de l’exécution des commandes d’un serveur de
mails.

Note: Certaines de ces valeurs peuvent ne pas être disponibles sur
  toutes les plate-formes Unix étant donné qu’il en existe des
  variations. Ces constantes sont définies là où elles sont définies
  par la plate- forme sous-jacente.

os.EX_OK

   Code de sortie signifiant qu’aucune erreur n’est arrivée.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_USAGE

   Code de sortie signifiant que les commandes n’ont pas été utilisées
   correctement, comme quand le mauvais nombre d’arguments a été
   donné.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_DATAERR

   Code de sortie signifiant que les données en entrées étaient
   incorrectes.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_NOINPUT

   Code de sortie signifiant qu’un des fichiers d’entrée n’existe pas
   ou n’est pas lisible.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_NOUSER

   Code de sortie signifiant qu’un utilisateur spécifié n’existe pas.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_NOHOST

   Code de sortie signifiant qu’un hôte spécifié n’existe pas.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_UNAVAILABLE

   Code de sortie signifiant qu’un service requis n’est pas
   disponible.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_SOFTWARE

   Code de sortie signifiant qu’une erreur interne d’un programme a
   été détectée.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_OSERR

   Code de sortie signifiant qu’une erreur du système d’exploitation a
   été détectée, comme l’incapacité à réaliser un *fork* ou à créer un
   tuyau (*pipe*).

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_OSFILE

   Code de sortie signifiant qu’un fichier n’existe pas, n’a pas pu
   être ouvert, ou avait une autre erreur.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_CANTCREAT

   Code de sortie signifiant qu’un fichier spécifié par l’utilisateur
   n’a pas pu être créé.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_IOERR

   Code de sortie signifiant qu’une erreur est apparue pendant une E/S
   sur un fichier.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_TEMPFAIL

   Code de sortie signifiant qu’un échec temporaire est apparu. Cela
   indique quelque chose qui pourrait ne pas être une erreur, comme
   une connexion au réseau qui n’a pas pu être établie pendant une
   opération ré-essayable.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_PROTOCOL

   Code de sortie signifiant qu’un protocole d’échange est illégal,
   invalide, ou non-compris.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_NOPERM

   Code de sortie signifiant qu’il manque certaines permissions pour
   réaliser une opération (mais n’est pas destiné au problèmes de
   système de fichiers).

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_CONFIG

   Code de sortie signifiant qu’une erreur de configuration est
   apparue.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.EX_NOTFOUND

   Code de sortie signifiant quelque chose comme « une entrée n’a pas
   été trouvée ».

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.fork()

   *Fork* un processus fils. Renvoie "0" dans le processus fils et
   l’id du processus fils dans le processus père. Si une erreur
   apparaît, une "OSError" est levée.

   Note that some platforms including FreeBSD <= 6.3, Cygwin and OS/2
   EMX have known issues when using fork() from a thread.

   Avertissement: Voit "ssl" pour les application qui utilisent le
     module SSL avec fork().

   Disponibilité : Unix.

os.forkpty()

   Fork un processus fils, en utilisant un nouveau pseudo-terminal
   comme terminal contrôlant le fils. Renvoie une paire "(pid, fd)" où
   *pid* vaut "0" dans le fils et l’id du processus fils dans le
   parent, et *fd* est le descripteur de fichier de la partie maître
   du pseudo-terminal. Pour une approche plus portable, utilisez le
   module "pty". Si une erreur apparaît, une "OSError" est levée.

   Disponibilité : certains dérivés Unix.

os.kill(pid, sig)

   Envoie le signal *sig* au processus *pid*. Les constantes pour les
   signaux spécifiques à la plate-forme hôte sont définies dans le
   module "signal".

   Windows : les signaux "signal.CTRL_C_EVENT" et
   "signal.CTRL_BREAK_EVENT" sont des signaux spéciaux qui ne peuvent
   être envoyés qu’aux processus consoles qui partagent une console
   commune (par exemple, certains sous-processus). Toute autre valeur
   pour *sig* amènera le processus a être tué sans condition par l’API
   TerminateProcess, et le code de retour sera mis à *sig*. La version
   Windows de "kill()" prend en plus les identificateurs de processus
   à tuer.

   Nouveau dans la version 2.7: Windows support

os.killpg(pgid, sig)

   Envoie le signal*sig* au groupe de processus *pgid*.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.nice(increment)

   Ajoute *increment*  à la priorité du processus. Renvoie la nouvelle
   priorité.

   Disponibilité : Unix.

os.plock(op)

   Verrouille les segments du programme en mémoire. La valeur de *op*
   (définie dans "<sys/lock.h>") détermine quels segments sont
   verrouillés.

   Disponibilité : Unix.

os.popen(…)
os.popen2(…)
os.popen3(…)
os.popen4(…)

   Run child processes, returning opened pipes for communications.
   These functions are described in section Création de Fichiers
   Objets.

os.spawnl(mode, path, …)
os.spawnle(mode, path, …, env)
os.spawnlp(mode, file, …)
os.spawnlpe(mode, file, …, env)
os.spawnv(mode, path, args)
os.spawnve(mode, path, args, env)
os.spawnvp(mode, file, args)
os.spawnvpe(mode, file, args, env)

   Exécute le programme *path* dans un nouveau processus.

   (Notez que le module "subprocess" fournit des outils plus puissants
   pour générer de nouveaux processus et récupérer leur valeur de
   retour. Il est préférable d’utiliser ce module que ces fonctions.
   Voyez surtout la section Replacing Older Functions with the
   subprocess Module.)

   Si *mode* vaut "P_NOWAIT", cette fonction renvoie le pid du nouveau
   processus, et si *mode* vaut "P_WAIT", la fonction renvoie le code
   de sortie du processus s’il se termine normalement, ou "-signal" où
   *signal* est le signal qui a tué le processus. Sur Windows, l’id du
   processus sera en fait l’identificateur du processus (*process
   handle*) et peut donc être utilisé avec la fonction "waitpid()".

   Les variantes « l » et « v » des fonctions "spawn*" diffèrent sur
   la manière de passer les arguments de ligne de commande. Les
   variantes « l » sont probablement les plus simples à utiliser si le
   nombre de paramètres est fixé lors de l’écriture du code. Les
   paramètres individuels deviennent alors des paramètres additionnels
   aux fonctions "spawn*()". Les variantes « v » sont préférables
   quand le nombre de paramètres est variable et qu’ils sont passés
   dans une liste ou un *tuple* dans le paramètre *args*. Dans tous
   les cas, les arguments aux processus fils devraient commencer avec
   le nom de la commande à lancer, mais ce n’est pas obligatoire.

   Les variantes qui incluent un « p »vers la fin ("spawnlp()",
   "spawnlpe()", "spawnvp()", et "spawnvpe()") utiliseront la variable
   d’environnement "PATH" pour localiser le programme *file*. Quand
   l’environnement est remplacé (en utilisant une des variantes
   "spawn*e", discutées dans le paragraphe suivant), le nouvel
   environnement est utilisé comme source de la variable
   d’environnement "PATH". Les autres variantes "spawnl()",
   "spawnle()", "spawnv()", et "spawnve()" n’utiliseront pas la
   variable d’environnement "PATH" pour localiser l’exécutable. *path*
   doit contenir un chemin absolue ou relatif approprié.

   Pour les fonctions "spawnle()", "spawnlpe()", "spawnve()", et
   "spawnvpe()" (notez qu’elles finissent toutes par « e »), le
   paramètre *env* doit être un *mapping* qui est utilisé pour définir
   les variables d’environnement du nouveau processus (celles-ci sont
   utilisées à la place de l’environnement du nouveau processus). Les
   fonctions "spawnl()", "spawnlp()", "spawnv()", et "spawnvp()"
   causent toutes un héritage de l’environnement du processus actuel
   par le processus fils. Notez que les clefs et les valeurs du
   dictionnaire *env* oivent être des chaînes de caractères. Des
   valeurs invalides pour les clefs ou les valeurs causera un échec de
   la fonction qui renvoiera "127".

   Par exemple, les appels suivants à "spawnlp()" et "spawnvpe()" sont
   équivalents :

      import os
      os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')

      L = ['cp', 'index.html', '/dev/null']
      os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)

   Disponibilité : Unix, Windows. "spawnlp()", "spawnlpe()",
   "spawnvp()", et "spawnvpe()" ne sont pas disponibles sur Windows.
   "spawnle()" et "spawnve()" ne sont pas sécurisés pour les appels
   concurrents (*thread-safe*) sur Windows, il est conseillé
   d’utiliser le module "subprocess" à la place.

   Nouveau dans la version 1.6.

os.P_NOWAIT
os.P_NOWAITO

   Valeurs possibles pour le paramètre *mode* de la famille de
   fonctions "spawn*". Si l’une de ces valeurs est donnée, les
   fonctions "spawn*()" renvoieront dès que le nouveau processus est
   créé, avec l’id du processus comme valeur de retour.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 1.6.

os.P_WAIT

   Valeur possible pour le paramètre *mode* de la famille de fonctions
   "spawn*". Si *mode* est défini par cette valeur, les fonctions
   "spawn*" ne renvoieront pas tant que le nouveau processus n’a pas
   été complété et renvoieront le code de sortie du processus si
   l’exécution est effectuée avec succès, ou "-signal" si un signal
   tue le processus.

   Disponibilité : Unix, Windows.

   Nouveau dans la version 1.6.

os.P_DETACH
os.P_OVERLAY

   Possible values for the *mode* parameter to the "spawn*" family of
   functions.  These are less portable than those listed above.
   "P_DETACH" is similar to "P_NOWAIT", but the new process is
   detached from the console of the calling process. If "P_OVERLAY" is
   used, the current process will be replaced; the "spawn*()" function
   will not return.

   Disponibilité : Windows.

   Nouveau dans la version 1.6.

os.startfile(path[, operation])

   lance un fichier avec son application associée.

   Quand *operation* n’est pas spécifié ou vaut "'open'", l’effet est
   le même qu’un double clic sur le fichier dans Windows Explorer, ou
   que de passer le nom du fichier en argument du programme **start**
   depuis l’invite de commande interactif : le fichier est ouvert avec
   l’application associée à l’extension (s’il y en a une).

   Quand une autre *operation* est donnée, ce doit être une «
   commande-verbe » qui spécifie ce qui devrait être fait avec le
   fichier. Les verbes habituels documentés par Microsoft sotn
   "'print'" et "'edit'" (qui doivent être utilisés sur des fichiers)
   ainsi que "'explore'" et "'find'" (qui doivent être utilisés sur
   des répertoires).

   "startfile()" termine dès que l’application associée est lancée.Il
   n’y a aucune option permettant d’attendre que l’application ne se
   ferme et aucun moyen de récupérer le statu de sortie de
   l’application. Le paramètre *path* est relatif au répertoire
   actuel. Si vous voulez utiliser un chemin absolu, assurez-vous que
   le premier caractère ne soit pas un slash ("'/'"). La fonction
   Win32 "ShellExecute()" sous-jacente ne fonctionne pas sinon.
   Utilisez la fonction "os.path.normpath()" pour vous assurer que le
   chemin est encodé correctement pour Win32.

   Disponibilité : Windows.

   Nouveau dans la version 2.0.

   Nouveau dans la version 2.5: The *operation* parameter.

os.system(command)

   Execute the command (a string) in a subshell.  This is implemented
   by calling the Standard C function "system()", and has the same
   limitations. Changes to "sys.stdin", etc. are not reflected in the
   environment of the executed command.

   Sur Unix, la valeur de retour est le statut de sortie du processus
   encodé dans le format spécifié pour "wait()". Notez que POSIX ne
   spécifie pas le sens de la valeur de retour de la fonction C
   "system()", donc la valeur de retour de la fonction Python est
   dépendante du système.

   On Windows, the return value is that returned by the system shell
   after running *command*, given by the Windows environment variable
   "COMSPEC": on **command.com** systems (Windows 95, 98 and ME) this
   is always "0"; on **cmd.exe** systems (Windows NT, 2000 and XP)
   this is the exit status of the command run; on systems using a non-
   native shell, consult your shell documentation.

   Le module "subprocess" fournit des outils plus puissants pour
   générer de nouveaux processus et pour récupérer leur résultat. Il
   est préférable d’utiliser ce module plutôt que d’utiliser cette
   fonction. Voir la section Replacing Older Functions with the
   subprocess Module de la documentation du module "subprocess" pour
   des informations plus précises et utiles.

   Disponibilité : Unix, Windows.

os.times()

   Return a 5-tuple of floating point numbers indicating accumulated
   (processor or other) times, in seconds.  The items are: user time,
   system time, children’s user time, children’s system time, and
   elapsed real time since a fixed point in the past, in that order.
   See the Unix manual page *times(2)* or the corresponding Windows
   Platform API documentation. On Windows, only the first two items
   are filled, the others are zero.

   Disponibilité Unix, Windows

os.wait()

   Attend qu’un processus fils soit complété, et renvoie un *tuple*
   contenant son pid et son stat de sortie : un nombre de 16 bits dont
   le *byte* de poids faible est le nombre correspondant au signal qui
   a tué le processus, et dont le *byte* de poids fort est le statut
   de sortie (si la signal vaut "0"). Le bit de poids fort du *byte*
   de poids faible est mis à 1 si un (fichier système) *core file* a
   été produit.

   Disponibilité : Unix.

os.waitpid(pid, options)

   Les détails de cette fonction diffèrent sur Unix et Windows.

   Sur Unix : attend qu’un processus fils donné par son id de
   processus *pid* soit complété , et renvoie un *tuple* contenant son
   pid et son statut de sortie (encodé comme pour "wait()"). La
   sémantique de cet appel est affecté par la valeur de l’argument
   entier *options*, qui devrait valoir "0" pour les opérations
   normales.

   Si *pid* est plus grand que "0", "waitpid()" introduit une requête
   pour des informations sur le statut du processus spécifié. Si *pid*
   vaut "0", la requête est pour le statut de tous les fils dans le
   groupe de processus du processus actuel. Si *pid* vaut "-1", la
   requête concerne tous les processus fils du processus actuel. Si
   *pid* est inférieur à "-1", une requête est faite pour le statut de
   chaque processus du groupe de processus donné par "-pid" (la valeur
   absolue de *pid*).

   Une "OSError" est levée avec la valeur de errno quand l’appel
   système renvoie "-1".

   Sur Windows : attend que qu’un processus donné par l’identificateur
   de processus (*process handle*) *pid*  soi complété, et renvoie un
   *tuple* contenant *pid* et son statut de sortir décalé de 8 bits
   bers la gauche (le décalage rend l’utilisation multiplate-forme
   plus facile). Un *pid* inférieur ou égal à "0" n’a aucune
   signification particulière sur Windows, et lève une exception.
   L’argument entier *options* n’a aucun effet. *pid* peut faire
   référence à tout processus dont l’id est connue pas nécessairement
   un processus fils. Les fonctions "spawn*" appelées avec "P_NOWAIT"
   renvoient des identificateurs de processus appropriés.

os.wait3(options)

   Similaire à la fonction "waitpid()", si ce n’est que qu’aucun
   argument *id* n’est donné, et qu’un 3-uple contenant l’id du
   processus fils, son statut de sortie, et une information sur
   l’utilisation des ressources est renvoyé. Référez-vous à
   "resource"."getrusage()" pour des détails sur les informations
   d’utilisation des ressources. L’argument *options* est le même que
   celui fourni à "waitpid()" et "wait4()".

   Disponibilité : Unix.

   Nouveau dans la version 2.5.

os.wait4(pid, options)

   Similaire à "waitpid()", si ce n’est qu’un 3-uple contenant l’id du
   processus fils, son statut de sortie, et des informations
   d’utilisation des ressources est renvoyé. Référez-vous à
   "resource"."getrusage()" pour desdétails sur les informations
   d’utilisation des ressources. Les arguments de "wait4()" sont les
   mêmes que ceux fournis à "waitpid()".

   Disponibilité : Unix.

   Nouveau dans la version 2.5.

os.WNOHANG

   L’option de "waitpid()" pour terminer immédiatement si aucun statut
   de processus fils n’est disponible dans l’immédiat. La fonction
   renvoie "(0, 0)" dans ce cas.

   Disponibilité : Unix.

os.WCONTINUED

   Cette option cause les processus fils à être reportés s’ils ont été
   continués après un arrêt du *job control* depuis leurs derniers
   reports de statuts.

   Availability: Some Unix systems.

   Nouveau dans la version 2.3.

os.WUNTRACED

   Cette option cause les processus fils à être reportés s’ils ont été
   stoppés mais que leur état actuel n’a pas été reporté depuis qu’ils
   ont été stoppés.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

Les fonctions suivantes prennent un code de statu tel que renvoyé par
"system()", "wait()", ou "waitpid()" en paramètre. Ils peuvent être
utilisés pour déterminer la disposition d’un processus.

os.WCOREDUMP(status)

   Renvoie "True" si un vidage système (*core dump*) a été généré pour
   le processus, sinon, renvoie "False".

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.WIFCONTINUED(status)

   Renvoie "True" si le processus a été continué après un arrêt du
   *job control*, renvoie "False" autrement.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.WIFSTOPPED(status)

   Renvoie "True" si le processus a été arrête, sinon renvoie "False".

   Disponibilité : Unix.

os.WIFSIGNALED(status)

   Renvoie "True" si le processus s’est terminé à cause d’un signal,
   sinon, renvoie "False".

   Disponibilité : Unix.

os.WIFEXITED(status)

   Renvoie "True" si le processus s’est terminé en faisant un appel
   système *exit(2)*, sinon, renvoie "False".

   Disponibilité : Unix.

os.WEXITSTATUS(status)

   Si "WIFEXITED(status)" vaut "True", renvoie le paramètre entier de
   l’appel système *exit(2)*. Sinon, la valeur de retour n’a pas de
   signification.

   Disponibilité : Unix.

os.WSTOPSIG(status)

   Renvoie le signal qui a causé l’arrêt du processus.

   Disponibilité : Unix.

os.WTERMSIG(status)

   Renvoie le signal qui a amené le processus à quitter.

   Disponibilité : Unix.


Diverses informations sur le système
====================================

os.confstr(name)

   Renvoie les valeurs de configuration en chaînes de caractères.
   *name* spécifie la valeur de configuration à récupérer. Ce peut
   être une chaîne de caractères représentant le nom d’une valeur
   système définie dans un nombre de standards (POSIX, Unix 95, Unix
   98, et d’autres). Certaines plate-formes définissent des noms
   supplémentaires également. Les noms connus par le système
   d’exploitation hôte sont données dans les clefs du dictionnaire
   "confstr_names". Pour les variables de configuration qui ne sont
   pas incluses dans ce *mapping*, passer un entier pour *name* est
   également accepté.

   Si la valeur de configuration spécifiée par *name* n’est pas
   définie, "None" est renvoyé.

   Si *name* est une chaîne de caractères et n’est pas connue, une
   "ValueError" est levée. Si une valeur spécifique pour *name* n’est
   pas supportée par le système hôte, même si elle est incluse dans
   "confstr_names", une "OSError" est levée avec "errno.EINVAL" pour
   numéro d’erreur.

   Disponibilité : Unix

os.confstr_names

   Dictionnaire liant les noms acceptés par "confstr()" aux valeurs
   entières définies pour ces noms par le système d’exploitation hôte.
   Cela peut être utilisé pour déterminer l’ensemble des noms connus
   du système.

   Disponibilité : Unix.

os.getloadavg()

   Renvoie le nombre de processus dans la file d’exécution du système
   en moyenne dans les dernières 1, 5, et 15 minutes, ou lève une
   "OSError" si la charge moyenne est impossible à récupérer.

   Disponibilité : Unix.

   Nouveau dans la version 2.3.

os.sysconf(name)

   Renvoie les valeurs de configuration en nombres entiers. Si la
   valeur de configuration définie par *name* n’est pas spécifiée,
   "-1" est renvoyé. Les commentaires concernant le paramètre *name*
   de "confstr()" s’appliquent également ici, le dictionnaire qui
   fournit les informations sur les noms connus est donné par
   "sysconf_names".

   Disponibilité : Unix.

os.sysconf_names

   Dictionnaire liant les noms acceptés par "sysconf()" aux valeurs
   entières définies pour ces noms par le système d’exploitation hôte.
   Cela peut être utilisé pour déterminer l’ensemble des noms connus
   du système.

   Disponibilité : Unix.

Les valeurs suivantes sont utilisées pour gérer les opérations de
manipulations de chemins. Elles sont définies pour toutes les plate-
formes.

Des opérations de plus haut niveau sur les chemins sont définies dans
le module "os.path".

os.curdir

   La chaîne de caractère constante utilisée par le système
   d’exploitation pour référencer le répertoire actuel. Ça vaut "'.'"
   pour Windows et POSIX. Également disponible par "os.path".

os.pardir

   La chaîne decaractère constante utilisée par le système
   d’exploitation pour référencer le répertoire parent. Ça vaut "'..'"
   pour Windows et POSIX. Également disponible par "os.path".

os.sep

   Le caractère utilisé par le système d’exploitation pour séparer les
   composantes des chemins. C’est "'/'" pour POSIX, et "'\\'" pour
   Windows. Notez que ce n’est pas suffisant pour pouvoir analyser ou
   concaténer correctement des chemins (utilisez alors
   "os.path.split()" et "os.path.join()"), mais ça peut s’avérer utile
   occasionnellement.  Également disponible par "os.path".

os.altsep

   Un caractère alternatif utilisé par le système d’exploitation pour
   séparer les composantes des chemins, ou "None" si un seul
   séparateur existe. Ça vaut "'/'" sur Windows où "sep" est un
   backslash "'\'". Également disponible par "os.path".

os.extsep

   Le caractère qui sépare la base du nom d’un fichier et son
   extension. Par exemple, le "'.'" de "os.py". Également disponible
   par "os.path".

   Nouveau dans la version 2.2.

os.pathsep

   Le caractère conventionnellement utilisé par le système
   d’exploitation pour séparer la recherche des composantes de chemin
   (comme dans la variable d’environnement "PATH"). Cela vaut "':'"
   pour POSIX, ou "';'" pour Windows. Également disponible par
   "os.path".

os.defpath

   Le chemin de recherche par défaut utilisé par "exec*" et "spawn*"
   si l’environnement n’a pas une clef "'PATH'". Également disponible
   par "os.path".

os.linesep

   La chaîne de caractères utilisée pour séparer (ou plutôt pour
   terminer) les lignes sur la plate-forme actuelle. Ce peut être un
   caractère unique (comme "'\n'" pour POSIX,) ou plusieurs caractères
   (comme "'\r\n'" pour Windows). N’utilisez pas *os.linesep* comme
   terminateur de ligne quand vous écrivez dans un fichier ouvert en
   mode *texte* (par défaut). Utilisez un unique "'\n'" à la place,
   sur toutes les plate-formes.

os.devnull

   Le chemin de fichier du périphérique *null*. Par exemple :
   "'/dev/null'" pour POSIX, "'nul'" our Windows. Également disponible
   par "os.path".

   Nouveau dans la version 2.4.


Miscellaneous Functions
=======================

os.urandom(n)

   Return a string of *n* random bytes suitable for cryptographic use.

   This function returns random bytes from an OS-specific randomness
   source.  The returned data should be unpredictable enough for
   cryptographic applications, though its exact quality depends on the
   OS implementation.  On a UNIX-like system this will query
   "/dev/urandom", and on Windows it will use "CryptGenRandom()".  If
   a randomness source is not found, "NotImplementedError" will be
   raised.

   For an easy-to-use interface to the random number generator
   provided by your platform, please see "random.SystemRandom".

   Nouveau dans la version 2.4.
